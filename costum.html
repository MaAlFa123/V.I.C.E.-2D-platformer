<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative 2D Platformer & Level Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            font-family: 'Courier New', Courier, monospace;
        }
        #editor-wrapper {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
        }
        #game-container {
            position: relative;
        }
        #gameCanvas {
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
            background-color: #000;
        }
        #game-timer-display {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            display: none; /* Hidden by default */
        }
        #controls-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 800px;
        }
        #controls {
            font-size: 1.2em;
            color: #333;
            background-color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 15px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border: 2px solid #555;
            border-radius: 5px;
            background-color: #fff;
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover, button.active {
            background-color: #333;
            color: #fff;
        }
        #editor-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
            justify-content: center;
            max-width: 800px;
        }
        #settings-panel, #timeline-settings-panel {
            width: 200px;
            background: #ffffff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        #settings-panel h3, #timeline-settings-panel h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #settings-panel label, #timeline-settings-panel label {
            font-size: 0.9em;
        }
        #settings-panel input, #settings-panel button, #settings-panel select,
        #timeline-settings-panel input, #timeline-settings-panel button, #timeline-settings-panel select {
            width: 100%;
            padding: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-section {
            border-top: 1px solid #eee;
            padding-top: 10px;
            margin-top: 10px;
        }
        #game-settings {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
            color: #333;
            width: 100%;
        }
        .settings-slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 50%;
        }
        #timeline-container {
            margin-top: 10px;
            width: 800px;
            text-align: center;
            color: #333;
        }
        #timeline-canvas {
            width: 100%;
            height: 60px;
            background-color: #ddd;
            border: 1px solid #555;
            cursor: pointer;
        }
        .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            padding: 0;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 50%;
            background: #f0f0f0;
        }
        .close-btn:hover {
            background: #ff4d4d;
            color: white;
            border-color: #ff4d4d;
        }
        #file-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="editor-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="game-timer-display">0.00</div>
        </div>
        <div id="settings-panel">
            <button class="close-btn" id="close-settings-panel">X</button>
            <div id="object-settings-content">
                <h3>Object Settings</h3>
                <div id="general-settings">
                    <label for="color-picker">Color:</label>
                    <input type="color" id="color-picker">
                    <button id="rotate-btn">Rotate</button>
                    <div class="settings-row">
                         <input type="checkbox" id="transparent-checkbox">
                         <label for="transparent-checkbox">Invisible in Play Mode</label>
                    </div>
                </div>
                <div id="text-settings" class="settings-section" style="display: none;">
                    <label for="text-content-input">Text:</label>
                    <input type="text" id="text-content-input">
                    <label for="font-size-input">Font Size:</label>
                    <input type="number" id="font-size-input" min="8" max="100">
                </div>
                <div id="button-laser-settings" class="settings-section" style="display: none;">
                    <label for="laser-direction-select">Set Laser Direction:</label>
                    <select id="laser-direction-select">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                 <div id="music-block-settings" class="settings-section" style="display: none;">
                    <label for="music-block-file">Music File:</label>
                    <input type="file" id="music-block-file" accept="audio/*">
                </div>
            </div>
        </div>
        <div id="timeline-settings-panel">
            <button class="close-btn" id="close-timeline-panel">X</button>
            <h3>Text Event</h3>
            <div id="event-text-settings">
                <label for="event-text-content">Text:</label>
                <input type="text" id="event-text-content">
                <label for="event-text-size">Size:</label>
                <input type="number" id="event-text-size" value="24">
                 <label for="event-text-color">Color:</label>
                <input type="color" id="event-text-color" value="#FFFFFF">
            </div>
        </div>
    </div>
    <div id="controls-container">
        <div id="controls">Press 'E' to toggle Editor Mode, 'Z' to Undo</div>
        <div id="editor-tools">
            <button class="tool-btn active" data-type="select">Select</button>
            <button class="tool-btn" data-type="platform">Platform</button>
            <button class="tool-btn" data-type="spike">Spike</button>
            <button class="tool-btn" data-type="button">Button</button>
            <button class="tool-btn" data-type="decay">Decay Block</button>
            <button class="tool-btn" data-type="delay">Delay Block</button>
             <button class="tool-btn" data-type="text">Text</button>
             <button class="tool-btn" data-type="music">Music</button>
            <button class="tool-btn" data-type="spawn">Spawn</button>
            <button class="tool-btn" data-type="laser_source">Laser</button>
            <button class="tool-btn" data-type="end">End</button>
            <button class="tool-btn" id="link-tool-btn" data-type="linker">Link</button>
        </div>
        <div id="game-settings">
             <div class="settings-slider-row">
                <label for="laser-speed-slider">Laser Speed:</label>
                <input type="range" id="laser-speed-slider" min="0.5" max="10" step="0.1" value="1.5">
            </div>
             <div class="settings-slider-row">
                <label for="player-speed-slider">Player Speed:</label>
                <input type="range" id="player-speed-slider" min="1" max="15" step="0.1" value="5">
            </div>
             <div class="settings-slider-row">
                 <label for="player-accel-slider">Player Accel:</label>
                <input type="range" id="player-accel-slider" min="0.1" max="2" step="0.05" value="0.4">
            </div>
             <div class="settings-slider-row">
                <label for="player-jump-slider">Player Jump:</label>
                <input type="range" id="player-jump-slider" min="5" max="25" step="0.5" value="13">
            </div>
        </div>
        <div id="timeline-container">
            <label>Text Event Timeline (Max 300s) - Click to add, Drag to move/resize, Right-click to delete</label>
            <canvas id="timeline-canvas" width="800" height="60"></canvas>
        </div>
        <div id="file-controls">
            <button id="saveButton">Save Level</button>
            <button id="loadButton">Load Level</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameTimerDisplay = document.getElementById('game-timer-display');
        const timelineCanvas = document.getElementById('timeline-canvas');
        const timelineCtx = timelineCanvas.getContext('2d');
        const controlsText = document.getElementById('controls');
        const exportButton = document.getElementById('exportButton');
        const toolButtons = document.querySelectorAll('.tool-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const objectSettingsContent = document.getElementById('object-settings-content');
        const colorPicker = document.getElementById('color-picker');
        const rotateBtn = document.getElementById('rotate-btn');
        const transparentCheckbox = document.getElementById('transparent-checkbox');
        const textSettingsDiv = document.getElementById('text-settings');
        const textContentInput = document.getElementById('text-content-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const buttonLaserSettingsDiv = document.getElementById('button-laser-settings');
        const laserDirectionSelect = document.getElementById('laser-direction-select');
        const musicBlockSettingsDiv = document.getElementById('music-block-settings');
        const musicBlockFileInput = document.getElementById('music-block-file');
        const laserSpeedSlider = document.getElementById('laser-speed-slider');
        const playerSpeedSlider = document.getElementById('player-speed-slider');
        const playerAccelSlider = document.getElementById('player-accel-slider');
        const playerJumpSlider = document.getElementById('player-jump-slider');
        const timelineSettingsPanel = document.getElementById('timeline-settings-panel');
        const eventTextContentInput = document.getElementById('event-text-content');
        const eventTextSizeInput = document.getElementById('event-text-size');
        const eventTextColorInput = document.getElementById('event-text-color');
        const closeSettingsPanelBtn = document.getElementById('close-settings-panel');
        const closeTimelinePanelBtn = document.getElementById('close-timeline-panel');
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const importFileInput = document.getElementById('import-file-input');
        
        let editorMode = false;
        const gridSize = 20;
        const editorCameraSpeed = 10;
        const TIMELINE_MAX_SECONDS = 300;

        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let mouseX = 0, mouseY = 0;
        let currentBlockType = 'select';
        let linkingState = { isLinking: false, sourceButtonId: null };
        let movePathState = { isSetting: false, sourceObjectId: null };
        let isSelectionRotated = false;
        let selectedObjectId = null;
        let gameWon = false;
        let gameTime = 0;
        
        let activeAudio = {};

        let selectedTimelineEventId = null;
        let timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        
        const worldWidth = 4000;
        const worldHeight = 20000;
        const gravity = 0.6;
        const MAX_JUMPS = 2;
        const JUMP_BUFFER_FRAMES = 8; 
        const DELAY_BLOCK_FADE_TIME = 300; 

        let history = [];
        let historyIndex = -1;

        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const savableObjects = levelObjects.map(obj => {
                const newObj = {...obj};
                if (newObj.type === 'music' && activeAudio[newObj.id]) {
                   // musicSrc is already a Blob URL which is fine
                }
                return newObj;
            });
            history.push(JSON.stringify({ objects: savableObjects, settings: levelSettings }));
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousState = JSON.parse(history[historyIndex]);
                levelObjects = previousState.objects;
                levelSettings = previousState.settings;
                laserSpeedSlider.value = levelSettings.laserSpeed;
                playerSpeedSlider.value = levelSettings.playerMaxSpeed;
                playerAccelSlider.value = levelSettings.playerAcceleration;
                playerJumpSlider.value = levelSettings.playerJumpPower;
                applySettingsToPlayer();
                drawTimeline();
            }
        }
        
        const playerStart = { x: 50, y: worldHeight - 60 };
        const player = {
            x: playerStart.x, y: playerStart.y, width: 40, height: 40,
            originalHeight: 40, velocityX: 0, velocityY: 0, jumpPower: 13,
            jumpsMade: 0, color: '#FFFFFF', acceleration: 0.4, friction: 0.3,
            maxSpeed: 5, isWallHolding: false, 
            wallClimbAcceleration: 0.2, maxWallClimbSpeed: 2.5, wallClimbFriction: 0.3,
            coyoteTimeCounter: 0, coyoteTimeDuration: 30,
            wallDirection: 0, isCrouching: false, isDashing: false, 
            dashSpeed: 0, dashFriction: 0.2, isSprinting: false, 
            sprintMultiplier: 1.6,
        };

        let levelObjects = [
            { id: Date.now(), type: 'platform', x: 0, y: worldHeight - 20, width: worldWidth, height: 20, color: '#999999', isSolid: true },
        ];
        
        let levelSettings = {
            laserSpeed: 1.5,
            playerMaxSpeed: 5,
            playerAcceleration: 0.4,
            playerJumpPower: 13,
            timelineEvents: [],
        };

        const camera = { x: 0, y: 0 };
        const keys = { w: false, a: false, s: false, d: false, shift: false };
        let jumpBufferCounter = 0;

        function applySettingsToPlayer() {
            player.maxSpeed = levelSettings.playerMaxSpeed;
            player.acceleration = levelSettings.playerAcceleration;
            player.jumpPower = levelSettings.playerJumpPower;
        }

        function checkRectCollision(objA, objB) {
            return objA.x < objB.x + objB.width && objA.x + objA.width > objB.x && objA.y < objB.y + objB.height && objA.y + objA.height > objB.y;
        }
        
        function sign(p1, p2, p3) { return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y); }

        function isPointInTriangle(pt, v1, v2, v3) {
            const d1 = sign(pt, v1, v2), d2 = sign(pt, v2, v3), d3 = sign(pt, v3, v1);
            const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0), has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
            return !(has_neg && has_pos);
        }

        function checkPlayerSpikeCollision(player, spike) {
            if (!checkRectCollision(player, spike)) return false; 
            const playerCorners = [ { x: player.x, y: player.y }, { x: player.x + player.width, y: player.y }, { x: player.x, y: player.y + player.height }, { x: player.x + player.width, y: player.y + player.height }, ];
            let v1, v2, v3;
            const o = spike.orientation || 'up';
            if (o === 'up') { v1 = { x: spike.x, y: spike.y + spike.height }; v2 = { x: spike.x + spike.width / 2, y: spike.y }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height }; } 
            else if (o === 'down') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y }; v3 = { x: spike.x + spike.width / 2, y: spike.y + spike.height }; } 
            else if (o === 'left') { v1 = { x: spike.x + spike.width, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y + spike.height }; v3 = { x: spike.x, y: spike.y + spike.height / 2 }; } 
            else if (o === 'right') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x, y: spike.y + spike.height }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height / 2 }; }
            return playerCorners.some(corner => isPointInTriangle(corner, v1, v2, v3));
        }

        function resetPlayer() {
            gameWon = false;
            gameTime = 0;
            applySettingsToPlayer();
            
            Object.values(activeAudio).forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });

            levelObjects.forEach(obj => { 
                if(obj.movePath) { obj.x = obj.movePath.start.x; obj.y = obj.movePath.start.y; obj.moveDirection = 1; }
                if(obj.type === 'button') obj.activated = false;
                if(obj.type === 'decay') obj.phased = false;
                if(obj.type === 'delay') { obj.phased = false; obj.delayTimer = 0; obj.isFading = false; }
                if(obj.type === 'laser_source') {
                    clearTimeout(obj.activationTimeout);
                    obj.isActive = false;
                }
            });
            let spawnPoint = levelObjects.find(obj => obj.type === 'spawn');
            const startPos = spawnPoint ? {x: spawnPoint.x, y: spawnPoint.y} : playerStart;
            Object.assign(player, { x: startPos.x, y: startPos.y, velocityX: 0, velocityY: 0, jumpsMade: 0, isDashing: false, isWallHolding: false, coyoteTimeCounter: 0, isCrouching: false, height: player.originalHeight });

            camera.x = 0;
            let targetCameraY = player.y - canvas.height / 2 + player.height / 2;
            camera.y = targetCameraY;
        }

        function canStandUp() {
            const standHitbox = { x: player.x, y: player.y - player.originalHeight / 2, width: player.width, height: player.originalHeight };
            return !levelObjects.some(obj => obj.isSolid && obj.type === 'platform' && checkRectCollision(standHitbox, obj));
        }
        
        function keyDownHandler(e) {
            const key = e.key.toLowerCase();
            if (key === 'z' && editorMode) {
                undo();
                return;
            }
            if (key === 'e') {
                editorMode = !editorMode;
                gameTimerDisplay.style.display = editorMode ? 'none' : 'block';
                controlsText.textContent = editorMode ? "EDITOR MODE [W,A,S,D to Pan | R to Rotate | Z to Undo]" : "PLAY MODE: W,A,S,D (Move) | SHIFT (Sprint)";
                if (!editorMode) { 
                    selectedObjectId = null; selectedTimelineEventId = null; updateSettingsPanel(); updateTimelineSettingsPanel(); resetPlayer(); 
                } else {
                    Object.values(activeAudio).forEach(audio => audio.pause());
                }
                return;
            }
            if (key === 'r' && editorMode) { isSelectionRotated = !isSelectionRotated; return; }
            if (key === 'd') keys.d = true; else if (key === 'a') keys.a = true;
            else if (key === 's') keys.s = true; else if (key === 'shift') keys.shift = true;
            else if (key === 'w') {
                keys.w = true; jumpBufferCounter = JUMP_BUFFER_FRAMES; 
                if (!e.repeat && !editorMode) {
                    if (!player.isWallHolding && player.jumpsMade < MAX_JUMPS) {
                        player.velocityY = -player.jumpPower; player.jumpsMade++;
                        jumpBufferCounter = 0; player.coyoteTimeCounter = 0;
                    }
                }
            }
        }

        function keyUpHandler(e) {
            const key = e.key.toLowerCase();
            if (key === 'd') keys.d = false; else if (key === 'a') keys.a = false;
            else if (key === 's') keys.s = false; else if (key === 'w') keys.w = false;
            else if (key === 'shift') keys.shift = false;
        }
        
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left + camera.x;
            mouseY = e.clientY - rect.top + camera.y;
        }

        function updateSettingsPanel() {
            const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
            
            textSettingsDiv.style.display = 'none';
            buttonLaserSettingsDiv.style.display = 'none';
            musicBlockSettingsDiv.style.display = 'none';
            objectSettingsContent.style.display = 'none';
            
            if (editorMode) {
                 if (selectedObject) {
                    settingsPanel.style.display = 'flex';
                    objectSettingsContent.style.display = 'block';
                    colorPicker.value = selectedObject.color || '#999999';
                    transparentCheckbox.checked = selectedObject.isSolid === false;

                    if (selectedObject.type === 'text') {
                        textSettingsDiv.style.display = 'block';
                        textContentInput.value = selectedObject.content || '';
                        fontSizeInput.value = selectedObject.fontSize || 16;
                    }
                     if (selectedObject.type === 'music') {
                        musicBlockSettingsDiv.style.display = 'block';
                    }
                    if (selectedObject.type === 'button' && selectedObject.linkedTo && selectedObject.linkedTo.some(id => {
                        const linked = levelObjects.find(o => o.id === id);
                        return linked && linked.type === 'laser_source';
                    })) {
                        buttonLaserSettingsDiv.style.display = 'block';
                        laserDirectionSelect.value = selectedObject.laserLinkDirection || 'left';
                    }
                } else {
                    settingsPanel.style.display = 'none';
                }
            } else {
                settingsPanel.style.display = 'none';
            }
        }
        
        function updateTimelineSettingsPanel() {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event && editorMode) {
                timelineSettingsPanel.style.display = 'flex';
                eventTextContentInput.value = event.text || '';
                eventTextSizeInput.value = event.fontSize || 24;
                eventTextColorInput.value = event.color || '#FFFFFF';
            } else {
                timelineSettingsPanel.style.display = 'none';
            }
        }
        
        function mouseDownHandler(e) {
            if (!editorMode) return;
            e.preventDefault();
            updateMousePos(e);
            
            if (currentBlockType === 'text') {
                const text = prompt("Enter text:", "Hello World");
                if (text) {
                    levelObjects.push({
                        id: Date.now() + Math.random(), type: 'text',
                        x: mouseX, y: mouseY, content: text,
                        color: '#FFFFFF', fontSize: 16, isSolid: false
                    });
                    saveState();
                }
                return;
            }

            const clickedObject = levelObjects.find(obj => mouseX >= obj.x && mouseX <= obj.x + obj.width && mouseY >= obj.y && mouseY <= obj.y + obj.height);

            if (linkingState.isLinking) {
                if (!clickedObject) return;
                if (clickedObject.type === 'button' && !linkingState.sourceButtonId) {
                    linkingState.sourceButtonId = clickedObject.id;
                } else if ((['decay', 'end', 'laser_source', 'music'].includes(clickedObject.type)) && linkingState.sourceButtonId) {
                    const sourceButton = levelObjects.find(obj => obj.id === linkingState.sourceButtonId);
                    if (sourceButton) {
                        if (!sourceButton.linkedTo) sourceButton.linkedTo = [];
                        if (!sourceButton.linkedTo.includes(clickedObject.id)) {
                             sourceButton.linkedTo.push(clickedObject.id);
                        }
                    }
                    linkingState.sourceButtonId = null; 
                    saveState();
                }
                return;
            }

            if (e.button === 0) { // Left Click
                if (currentBlockType === 'select') {
                    selectedObjectId = clickedObject ? clickedObject.id : null;
                    selectedTimelineEventId = null;
                    if (clickedObject && (clickedObject.type === 'platform' || clickedObject.type === 'delay')) {
                        movePathState.isSetting = true;
                        movePathState.sourceObjectId = clickedObject.id;
                    }
                    updateSettingsPanel();
                    updateTimelineSettingsPanel();
                } else { // Creation mode
                    selectedObjectId = null; updateSettingsPanel();
                    isDragging = true;
                    dragStartX = Math.floor(mouseX / gridSize) * gridSize;
                    dragStartY = Math.floor(mouseY / gridSize) * gridSize;
                }
            } else if (e.button === 2) { 
                if (clickedObject) {
                    if (clickedObject.movePath) { delete clickedObject.movePath; saveState(); } 
                    else {
                        levelObjects = levelObjects.filter(p => p.id !== clickedObject.id);
                        if (selectedObjectId === clickedObject.id) { selectedObjectId = null; updateSettingsPanel(); }
                        saveState();
                    }
                }
            }
        }

        function mouseUpHandler(e) {
            if (!editorMode) return;
            if (movePathState.isSetting) { 
                const sourceObject = levelObjects.find(obj => obj.id === movePathState.sourceObjectId);
                if (sourceObject) {
                    sourceObject.movePath = { start: { x: sourceObject.x, y: sourceObject.y }, end: { x: mouseX - sourceObject.width / 2, y: mouseY - sourceObject.height / 2 } };
                    sourceObject.moveSpeed = 2; sourceObject.moveDirection = 1;
                    saveState();
                }
                movePathState.isSetting = false; movePathState.sourceObjectId = null;
                return;
            }
            if (!isDragging || linkingState.isLinking) return;
            isDragging = false;
            const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
            const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
            let width = Math.abs(endX - dragStartX), height = Math.abs(endY - dragStartY);
            if (isSelectionRotated) [width, height] = [height, width];
            const newObject = {
                id: Date.now() + Math.random(), type: currentBlockType,
                x: Math.min(dragStartX, endX), y: Math.min(dragStartY, endY),
                width: width, height: height, color: '#999999', isSolid: true
            };
            if (newObject.width > 0 && newObject.height > 0) {
                 if(['spawn', 'end'].includes(newObject.type)){
                    levelObjects = levelObjects.filter(o => o.type !== newObject.type); 
                    newObject.width = gridSize; newObject.height = gridSize;
                    if(newObject.type === 'spawn') newObject.color = '#00e676';
                    if(newObject.type === 'end') newObject.color = '#8e24aa';
                 }
                 if(newObject.type === 'laser_source') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#ffa500'; newObject.orientation = 'left';
                    newObject.isActive = false; newObject.position = 0;
                 }
                  if(newObject.type === 'music') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#3399ff'; newObject.isSolid = false;
                 }
                 if(newObject.type === 'button') { newObject.activated = false; newObject.color = '#ff0000'; }
                 if(newObject.type === 'decay') { newObject.phased = false; newObject.color = '#444444'; }
                 if(newObject.type === 'delay') { newObject.phased = false; newObject.delayTimer = 0; newObject.color = '#666666'; newObject.isFading = false; }
                 if(newObject.type === 'spike') { newObject.color = '#ff0000'; newObject.orientation = 'up'; }
                 levelObjects.push(newObject);
                 saveState();
            }
        }

        toolButtons.forEach(button => {
            button.addEventListener('click', () => {
                toolButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentBlockType = button.dataset.type;
                linkingState.isLinking = currentBlockType === 'linker';
                linkingState.sourceButtonId = null;
                isSelectionRotated = false;
            });
        });
        
        colorPicker.addEventListener('input', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.color = e.target.value; saveState(); }
            }
        });

        transparentCheckbox.addEventListener('change', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.isSolid = !e.target.checked; saveState(); }
            }
        });
        
        textContentInput.addEventListener('input', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'text') {
                    selectedObject.content = e.target.value;
                    saveState();
                }
            }
        });

        fontSizeInput.addEventListener('input', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'text') {
                    selectedObject.fontSize = parseInt(e.target.value, 10);
                    saveState();
                }
            }
        });

        laserDirectionSelect.addEventListener('change', (e) => {
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'button') {
                    selectedObject.laserLinkDirection = e.target.value;
                    saveState();
                }
            }
        });

        musicBlockFileInput.addEventListener('change', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                const file = e.target.files[0];
                if (selectedObject && selectedObject.type === 'music' && file) {
                    const fileURL = URL.createObjectURL(file);
                    selectedObject.musicSrc = fileURL;
                    const audio = new Audio(fileURL);
                    audio.loop = true;
                    activeAudio[selectedObject.id] = audio;
                    saveState();
                }
            }
        });
        
        rotateBtn.addEventListener('click', () => {
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    if (selectedObject.type === 'spike' || selectedObject.type === 'laser_source') {
                        const orientations = ['up', 'right', 'down', 'left'];
                        const currentIndex = orientations.indexOf(selectedObject.orientation || 'up');
                        selectedObject.orientation = orientations[(currentIndex + 1) % 4];
                    } else {
                        [selectedObject.width, selectedObject.height] = [selectedObject.height, selectedObject.width];
                    }
                    saveState();
                }
            }
        });
        
        laserSpeedSlider.addEventListener('input', (e) => {
            levelSettings.laserSpeed = parseFloat(e.target.value);
            saveState();
        });
        playerSpeedSlider.addEventListener('input', (e) => {
            levelSettings.playerMaxSpeed = parseFloat(e.target.value);
            applySettingsToPlayer();
            saveState();
        });
        playerAccelSlider.addEventListener('input', (e) => {
            levelSettings.playerAcceleration = parseFloat(e.target.value);
            applySettingsToPlayer();
            saveState();
        });
        playerJumpSlider.addEventListener('input', (e) => {
            levelSettings.playerJumpPower = parseFloat(e.target.value);
            applySettingsToPlayer();
            saveState();
        });

        timelineCanvas.addEventListener('mousedown', (e) => {
            if (!editorMode) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const time = (clickX / rect.width) * TIMELINE_MAX_SECONDS;

            let clickedOnEvent = false;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    selectedTimelineEventId = event.id;
                    selectedObjectId = null;
                    if (clickX < eventStartX + 5) { // Left edge resize
                        timelineDragState = { isDragging: false, isResizing: 'left', targetId: event.id };
                    } else if (clickX > eventEndX - 5) { // Right edge resize
                        timelineDragState = { isDragging: false, isResizing: 'right', targetId: event.id };
                    } else { // Dragging
                        timelineDragState = { isDragging: true, isResizing: null, targetId: event.id, offset: time - event.startTime };
                    }
                    clickedOnEvent = true;
                    break;
                }
            }

            if (!clickedOnEvent) {
                selectedTimelineEventId = Date.now();
                levelSettings.timelineEvents.push({
                    id: selectedTimelineEventId,
                    startTime: time,
                    duration: 10,
                    text: 'New Event',
                    fontSize: 24,
                    color: '#FFFFFF'
                });
                timelineDragState = { isDragging: true, isResizing: null, targetId: selectedTimelineEventId, offset: 0 };
            }
            updateSettingsPanel();
            updateTimelineSettingsPanel();
            drawTimeline();
        });

        timelineCanvas.addEventListener('mousemove', (e) => {
            if (!editorMode || (!timelineDragState.isDragging && !timelineDragState.isResizing)) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const time = (mouseX / rect.width) * TIMELINE_MAX_SECONDS;
            const targetEvent = levelSettings.timelineEvents.find(ev => ev.id === timelineDragState.targetId);
            if (!targetEvent) return;

            if (timelineDragState.isDragging) {
                targetEvent.startTime = Math.max(0, time - timelineDragState.offset);
            } else if (timelineDragState.isResizing === 'left') {
                const oldEndTime = targetEvent.startTime + targetEvent.duration;
                targetEvent.startTime = Math.max(0, time);
                targetEvent.duration = oldEndTime - targetEvent.startTime;
            } else if (timelineDragState.isResizing === 'right') {
                targetEvent.duration = Math.max(1, time - targetEvent.startTime);
            }
            drawTimeline();
        });

        timelineCanvas.addEventListener('mouseup', () => {
            if (timelineDragState.isDragging || timelineDragState.isResizing) {
                saveState();
            }
            timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        });

        timelineCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!editorMode) return;
            
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;

            let clickedOnEvent = null;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    clickedOnEvent = event;
                    break;
                }
            }

            if(clickedOnEvent) {
                levelSettings.timelineEvents = levelSettings.timelineEvents.filter(ev => ev.id !== clickedOnEvent.id);
                if (selectedTimelineEventId === clickedOnEvent.id) {
                    selectedTimelineEventId = null;
                    updateTimelineSettingsPanel();
                }
                drawTimeline();
                saveState();
            }
        });
        
        eventTextContentInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.text = e.target.value; saveState(); }
        });
        eventTextSizeInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.fontSize = parseInt(e.target.value, 10); saveState(); }
        });
        eventTextColorInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.color = e.target.value; saveState(); }
        });
        
        closeSettingsPanelBtn.addEventListener('click', () => {
            selectedObjectId = null;
            updateSettingsPanel();
        });

        closeTimelinePanelBtn.addEventListener('click', () => {
            selectedTimelineEventId = null;
            updateTimelineSettingsPanel();
            drawTimeline(); 
        });


        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        canvas.addEventListener('mousemove', updateMousePos);
        canvas.addEventListener('mousedown', mouseDownHandler);
        canvas.addEventListener('mouseup', mouseUpHandler);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        saveButton.addEventListener('click', () => {
            const data = JSON.stringify({ objects: levelObjects, settings: levelSettings }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        loadButton.addEventListener('click', () => {
            importFileInput.click();
        });

        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.objects && data.settings) {
                        levelObjects = data.objects;
                        levelSettings = data.settings;
                        
                        activeAudio = {};
                        levelObjects.forEach(obj => {
                            if (obj.type === 'music' && obj.musicSrc) {
                                const audio = new Audio(obj.musicSrc);
                                audio.loop = true;
                                activeAudio[obj.id] = audio;
                            }
                        });

                        laserSpeedSlider.value = levelSettings.laserSpeed;
                        playerSpeedSlider.value = levelSettings.playerMaxSpeed;
                        playerAccelSlider.value = levelSettings.playerAcceleration;
                        playerJumpSlider.value = levelSettings.playerJumpPower;
                        applySettingsToPlayer();
                        
                        saveState(); 
                        drawTimeline();
                        alert('Level loaded successfully!');
                    } else {
                        alert('Invalid level file format.');
                    }
                } catch (error) {
                    alert('Error loading or parsing level file.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
            importFileInput.value = ''; // Reset input
        });

        function drawLevelObjects() {
            levelObjects.forEach(obj => {
                if (!editorMode && obj.isSolid === false) { return; }
                let color = obj.color || '#999';
                ctx.fillStyle = color;
                ctx.globalAlpha = (editorMode && obj.isSolid === false) ? 0.5 : 1.0;
                switch(obj.type) {
                    case 'platform': case 'spawn': case 'laser_source': case 'end':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'music':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(obj.x + obj.width * 0.4, obj.y + obj.height * 0.7, obj.width * 0.15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillRect(obj.x + obj.width * 0.55, obj.y + obj.height * 0.2, obj.width * 0.1, obj.height * 0.5);
                        ctx.fillRect(obj.x + obj.width * 0.4, obj.y + obj.height * 0.2, obj.width * 0.25, obj.height*0.1);
                        break;
                    case 'text':
                        ctx.font = `${obj.fontSize || 16}px 'Courier New'`; ctx.fillText(obj.content || '', obj.x, obj.y); break;
                    case 'spike':
                        ctx.beginPath();
                        let o = obj.orientation || 'up';
                        if (o === 'up') { ctx.moveTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); } 
                        else if (o === 'down') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width / 2, obj.y + obj.height); } 
                        else if (o === 'left') { ctx.moveTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); ctx.lineTo(obj.x, obj.y + obj.height / 2); } 
                        else if (o === 'right') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2); }
                        ctx.closePath(); ctx.fill(); break;
                    case 'button':
                        ctx.fillStyle = obj.activated ? '#00ff00' : color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'decay':
                        ctx.globalAlpha = obj.phased ? 0.3 : (obj.isSolid === false ? 0.2 : 1.0); ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'delay':
                         ctx.globalAlpha = (1.0 - (obj.delayTimer / DELAY_BLOCK_FADE_TIME)) * ((editorMode && obj.isSolid === false) ? 0.5 : 1.0);
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                }
                ctx.globalAlpha = 1.0; 
            });
        }
        
        function drawChasingLaser() {
            levelObjects.forEach(laserSource => {
                if (laserSource.type === 'laser_source' && laserSource.isActive) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 4;
                    let o = laserSource.orientation || 'left';
                    if (o === 'left') { ctx.fillRect(laserSource.position, 0, 10, worldHeight); ctx.strokeRect(laserSource.position, 0, 10, worldHeight); } 
                    else if (o === 'right') { ctx.fillRect(laserSource.position - 10, 0, 10, worldHeight); ctx.strokeRect(laserSource.position - 10, 0, 10, worldHeight); } 
                    else if (o === 'up') { ctx.fillRect(0, laserSource.position, worldWidth, 10); ctx.strokeRect(0, laserSource.position, worldWidth, 10); } 
                    else if (o === 'down') { ctx.fillRect(0, laserSource.position - 10, worldWidth, 10); ctx.strokeRect(0, laserSource.position - 10, worldWidth, 10); }
                }
            });
        }

        function drawSelectionArrows(obj) {
            ctx.fillStyle = 'yellow';
            const size = 10;
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y - size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height + size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y + obj.height); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x - size, obj.y + obj.height / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width + size, obj.y + obj.height / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
        }

        function drawEditorElements() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1;
            for (let x = 0; x < worldWidth; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke(); }
            for (let y = 0; y < worldHeight; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke(); }
            if (isDragging) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
                const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
                let rectW = Math.abs(endX - dragStartX), rectH = Math.abs(endY - dragStartY);
                if (isSelectionRotated) [rectW, rectH] = [rectH, rectW];
                ctx.fillRect(Math.min(dragStartX, endX), Math.min(dragStartY, endY), rectW, rectH);
            }
            if (movePathState.isSetting) {
                const sourceObject = levelObjects.find(obj => obj.id === movePathState.sourceObjectId);
                if (sourceObject) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(sourceObject.x + sourceObject.width / 2, sourceObject.y + sourceObject.height / 2);
                    ctx.lineTo(mouseX, mouseY);
                    ctx.stroke();
                }
            }
            levelObjects.forEach(obj => {
                if (obj.movePath) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(obj.movePath.start.x + obj.width / 2, obj.movePath.start.y + obj.height / 2);
                    ctx.lineTo(obj.movePath.end.x + obj.width / 2, obj.movePath.end.y + obj.height / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    drawSelectionArrows(selectedObject);
                    if (selectedObject.type === 'laser_source') {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                        const o = selectedObject.orientation || 'left';
                        if (o === 'left') ctx.fillRect(selectedObject.x, 0, worldWidth, worldHeight);
                        if (o === 'right') ctx.fillRect(0, 0, selectedObject.x, worldHeight);
                        if (o === 'up') ctx.fillRect(0, selectedObject.y, worldWidth, worldHeight);
                        if (o === 'down') ctx.fillRect(0, 0, worldWidth, selectedObject.y);
                    }
                }
            }
            levelObjects.forEach(obj => {
                if (obj.type === 'button' && obj.linkedTo) {
                    obj.linkedTo.forEach(targetId => {
                        const targetObj = levelObjects.find(t => t.id === targetId);
                        if(targetObj) {
                            ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)'; ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height / 2);
                            ctx.lineTo(targetObj.x + targetObj.width / 2, targetObj.y + targetObj.height / 2);
                            ctx.stroke();
                        }
                    });
                }
            });
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawWinMessage() {
            ctx.fillStyle = 'white';
            ctx.font = '60px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('YOU WIN!', camera.x + canvas.width / 2, camera.y + canvas.height/2);
        }
        
        function drawActiveTextEvents() {
            levelSettings.timelineEvents.forEach(event => {
                if (gameTime >= event.startTime && gameTime < event.startTime + event.duration) {
                    ctx.fillStyle = event.color || '#FFFFFF';
                    ctx.font = `${event.fontSize || 24}px 'Courier New'`;
                    ctx.textAlign = 'center';
                    ctx.fillText(event.text, camera.x + canvas.width / 2, camera.y + canvas.height / 4);
                }
            });
        }

        function drawTimeline() {
            timelineCtx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            timelineCtx.fillStyle = '#ddd';
            timelineCtx.fillRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            
            levelSettings.timelineEvents.forEach(event => {
                const x = (event.startTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                const width = (event.duration / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = '#ADD8E6';
                timelineCtx.fillRect(x, 0, width, timelineCanvas.height);
                if (event.id === selectedTimelineEventId) {
                    timelineCtx.strokeStyle = 'yellow';
                    timelineCtx.lineWidth = 3;
                    timelineCtx.strokeRect(x, 0, width, timelineCanvas.height);
                }
            });

            if (!editorMode) {
                const playheadX = (gameTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = 'red';
                timelineCtx.fillRect(playheadX - 1, 0, 2, timelineCanvas.height);
            }
        }

        function update() {
            if (!editorMode) {
                if(gameWon) {
                    // Game is won
                } else {
                    gameTime += 1 / 60; // Assuming 60 FPS
                    gameTimerDisplay.textContent = gameTime.toFixed(2);
                    
                    let onGround = false;
                    
                    levelObjects.forEach(obj => {
                        if (obj.movePath) {
                            const target = obj.moveDirection === 1 ? obj.movePath.end : obj.movePath.start;
                            const dx = target.x - obj.x, dy = target.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < obj.moveSpeed) {
                                obj.x = target.x; obj.y = target.y; obj.moveDirection *= -1;
                            } else {
                                const moveX = (dx / dist) * obj.moveSpeed, moveY = (dy / dist) * obj.moveSpeed;
                                obj.x += moveX; obj.y += moveY;
                                if (checkRectCollision(player, { ...obj, y: obj.y - moveY, x: obj.x - moveX })) { player.x += moveX; player.y += moveY; }
                            }
                        }
                    });
                    
                    levelObjects.forEach(laserSource => {
                        if(laserSource.type === 'laser_source' && laserSource.isActive) {
                            let o = laserSource.orientation || 'left';
                            if(o === 'left' || o === 'up') laserSource.position += levelSettings.laserSpeed;
                            else laserSource.position -= levelSettings.laserSpeed;

                            let laserHitbox;
                            if(o === 'left') laserHitbox = {x: laserSource.position, y: 0, width: 10, height: worldHeight};
                            if(o === 'right') laserHitbox = {x: laserSource.position - 10, y: 0, width: 10, height: worldHeight};
                            if(o === 'up') laserHitbox = {x: 0, y: laserSource.position, width: worldWidth, height: 10};
                            if(o === 'down') laserHitbox = {x: 0, y: laserSource.position - 10, width: worldWidth, height: 10};
                            if(laserHitbox && checkRectCollision(player, laserHitbox)) resetPlayer();
                        }
                    });
                    
                    const touchingHitbox = { x: player.x - 1, y: player.y - 1, width: player.width + 2, height: player.height + 2 };
                    levelObjects.forEach(obj => {
                        if (obj.type === 'delay') {
                            if (!obj.isFading && obj.isSolid && checkRectCollision(touchingHitbox, obj)) {
                                obj.isFading = true;
                            }
                            if (obj.isFading) {
                                obj.delayTimer = Math.min(DELAY_BLOCK_FADE_TIME, obj.delayTimer + 1);
                            }
                            obj.phased = obj.delayTimer >= DELAY_BLOCK_FADE_TIME;
                        }
                    });

                    if (jumpBufferCounter > 0) jumpBufferCounter--;
                    
                    let wallTouchDirection = 0;
                    
                    if (player.isWallHolding) {
                        let isStillNextToWall = false;
                        const checkRect = { x: player.x + (player.wallDirection === 1 ? player.width : -1), y: player.y, width: 1, height: player.height };
                        for (const obj of levelObjects) {
                            if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased)  || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(checkRect, obj)) {
                                isStillNextToWall = true; break;
                            }
                        }
                        if (!isStillNextToWall) { 
                            player.isWallHolding = false;
                        } else {
                            player.velocityX = 0;
                            if (keys.w) {
                                player.velocityY -= player.wallClimbAcceleration;
                                if (player.velocityY < -player.maxWallClimbSpeed) player.velocityY = -player.maxWallClimbSpeed;
                            } else if (keys.s) {
                                player.velocityY += player.wallClimbAcceleration;
                                if (player.velocityY > player.maxWallClimbSpeed) player.velocityY = player.maxWallClimbSpeed;
                            } else {
                                if (player.velocityY > 0) {
                                    player.velocityY -= player.wallClimbFriction;
                                    if (player.velocityY < 0) player.velocityY = 0;
                                } else if (player.velocityY < 0) {
                                    player.velocityY += player.wallClimbFriction;
                                    if (player.velocityY > 0) player.velocityY = 0;
                                }
                            }
                            const isPressingAway = (keys.a && player.wallDirection === 1) || (keys.d && player.wallDirection === -1);
                            if (isPressingAway) {
                                player.isWallHolding = false; 
                                player.coyoteTimeCounter = player.coyoteTimeDuration; 
                                player.jumpsMade = 1;
                            }
                        }
                    } 
                    
                    if (!player.isWallHolding) {
                        player.isSprinting = keys.shift && !player.isCrouching && !player.isDashing;
                        let currentMaxSpeed = player.maxSpeed * (player.isSprinting ? player.sprintMultiplier : 1);
                        if (!player.isDashing) {
                            if (keys.d) { player.velocityX = Math.min(currentMaxSpeed, player.velocityX + player.acceleration); } 
                            else if (keys.a) { player.velocityX = Math.max(-currentMaxSpeed, player.velocityX - player.acceleration); } 
                            else {
                                if (player.velocityX > 0) { player.velocityX = Math.max(0, player.velocityX - player.friction); } 
                                else if (player.velocityX < 0) { player.velocityX = Math.min(0, player.velocityX + player.friction); }
                            }
                        }
                        if (player.coyoteTimeCounter > 0) { player.coyoteTimeCounter--; player.velocityY = gravity * 0.5; } 
                        else { player.velocityY += gravity; }
                    }
                    
                    const touchingGround = levelObjects.some(obj => obj.isSolid && (obj.type === 'platform' || (obj.type === 'delay' && !obj.phased)) && checkRectCollision({x:player.x, y:player.y+1, width: player.width, height:player.height}, obj));
                    if (keys.s && !player.isWallHolding && touchingGround) { 
                        if (player.isSprinting && !player.isDashing) {
                            player.isDashing = true;
                            player.dashSpeed = player.maxSpeed * player.sprintMultiplier * 1.5;
                            player.velocityX = player.dashSpeed * Math.sign(player.velocityX || 1);
                        }
                        if (!player.isCrouching) {
                            player.y += player.originalHeight / 2;
                            player.height = player.originalHeight / 2;
                            player.isCrouching = true;
                        }
                    } else if (player.isCrouching && canStandUp()) { 
                        player.y -= player.originalHeight / 2;
                        player.height = player.originalHeight;
                        player.isCrouching = false;
                        player.isDashing = false;
                    }
                    if (player.isDashing) { 
                        player.dashSpeed -= player.dashFriction;
                        if (player.dashSpeed <= 0) player.isDashing = false;
                        player.velocityX = player.dashSpeed * Math.sign(player.velocityX);
                    }

                    player.x += player.velocityX;
                    levelObjects.forEach(obj => {
                         if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                            if (player.velocityX > 0) { player.x = obj.x - player.width; wallTouchDirection = 1; } 
                            else if (player.velocityX < 0) { player.x = obj.x + obj.width; wallTouchDirection = -1; }
                            player.velocityX = 0;
                         }
                    });

                    player.y += player.velocityY;
                    
                    onGround = false;
                    levelObjects.forEach(obj => {
                        if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                            if (player.isWallHolding && player.velocityY < 0 && (player.y + player.height <= obj.y + Math.abs(player.wallClimbAcceleration * (keys.w ? -1 : 1)))) {
                                player.y = obj.y - player.height; onGround = true; player.isWallHolding = false;
                            } else if (player.velocityY >= 0 && player.y - player.velocityY + player.height <= obj.y + 1) {
                                player.y = obj.y - player.height; player.velocityY = 0; onGround = true; 
                                player.isWallHolding = false; player.jumpsMade = 0; player.coyoteTimeCounter = 0;
                                if (jumpBufferCounter > 0) {
                                    player.velocityY = -player.jumpPower; player.jumpsMade = 1; jumpBufferCounter = 0;
                                }
                            } else if (player.velocityY < 0) {
                                player.y = obj.y + obj.height; player.velocityY = 0;
                            }
                        }
                    });

                    levelObjects.forEach(obj => {
                        if (obj.isSolid && obj.type === 'spike' && checkPlayerSpikeCollision(player, obj)) { resetPlayer(); } 
                        else if (checkRectCollision(player, obj)) {
                            if (obj.type === 'button' && !obj.activated) {
                                obj.activated = true;
                                if (obj.linkedTo) {
                                    obj.linkedTo.forEach(targetId => {
                                        const targetObj = levelObjects.find(t => t.id === targetId);
                                        if(targetObj) {
                                            if (targetObj.type === 'decay') {
                                                targetObj.phased = true;
                                                setTimeout(() => { targetObj.phased = false; obj.activated = false; }, 10000);
                                            }
                                            if (targetObj.type === 'end') {
                                                gameWon = true;
                                            }
                                            if (targetObj.type === 'music' && activeAudio[targetObj.id]) {
                                                 Object.values(activeAudio).forEach(audio => audio.pause());
                                                 activeAudio[targetObj.id].currentTime = 0;
                                                 activeAudio[targetObj.id].play();
                                            }
                                            if (targetObj.type === 'laser_source') {
                                                levelObjects.forEach(l => { if(l.type === 'laser_source') { l.isActive = false; clearTimeout(l.activationTimeout); } });
                                                if (obj.laserLinkDirection) {
                                                    targetObj.orientation = obj.laserLinkDirection;
                                                }
                                                let o = targetObj.orientation || 'left';
                                                if (o === 'left' || o === 'right') targetObj.position = targetObj.x;
                                                else targetObj.position = targetObj.y;
                                                targetObj.activationTimeout = setTimeout(() => { targetObj.isActive = true; }, 500);
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    });
                    
                    if (!player.isWallHolding && !onGround && wallTouchDirection !== 0) {
                        player.isWallHolding = true;
                        player.wallDirection = wallTouchDirection;
                        player.jumpsMade = 0;
                        player.coyoteTimeCounter = 0;
                        player.velocityY = 0;
                    }
                    
                    if (player.x < 0) player.x = 0;
                    if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
                }
            }

            if (editorMode) {
                if (keys.d) camera.x += editorCameraSpeed; if (keys.a) camera.x -= editorCameraSpeed;
                if (keys.s) camera.y += editorCameraSpeed; if (keys.w) camera.y -= editorCameraSpeed;
            } else {
                let targetCameraX = player.x - canvas.width / 2 + player.width / 2;
                let targetCameraY = player.y - canvas.height / 2 + player.height / 2;
                camera.x += (targetCameraX - camera.x) * 0.1;
                camera.y += (targetCameraY - camera.y) * 0.1;
            }
           
            if (camera.x < 0) camera.x = 0; if (camera.x + canvas.width > worldWidth) camera.x = worldWidth - canvas.width;
            if (camera.y < 0) camera.y = 0; if (camera.y + canvas.height > worldHeight) camera.y = worldHeight - canvas.height;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            drawLevelObjects();
            if (editorMode) {
                drawEditorElements();
            } else {
                drawChasingLaser();
            }
            if(!gameWon) {
                drawPlayer();
            }
            
            ctx.restore();

            if (!editorMode) {
                drawActiveTextEvents();
            }

            if (gameWon) {
                drawWinMessage();
            }

            drawTimeline();
            requestAnimationFrame(update);
        }

        saveState(); // Initial state for undo
        resetPlayer();
        update();
    </script>
</body>
</html>

