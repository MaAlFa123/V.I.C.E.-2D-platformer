<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>V.I.C.E.2D.PLATFORMER</title>
    <style>
        /* ... (semua style CSS tetap sama) ... */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            /* ... (style body tidak berubah) ... */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden; /* Mencegah scroll */
        }

        /* --- STYLE PRELOADER & INTRO --- */
        /* ... (style preloader & intro tidak berubah) ... */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #ff4500; 
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 199;
            color: white;
            font-size: 2.5em;
            text-align: center;
        }
        .intro-line {
            opacity: 0;
            transition: opacity 1.5s ease-in-out;
            position: absolute;
        }
        #intro-line-2 {
            font-size: 0.7em;
            margin-top: 60px;
            color: #ccc;
        }


        /* --- STYLE MENU UTAMA & SUBMENU --- */
        /* ... (style menu & submenu tidak berubah) ... */
        .fullscreen-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f2f5;
            display: none; /* Default tersembunyi */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            gap: 20px;
            padding: 20px;
            overflow-y: auto;
        }
        #main-menu {
            display: none; /* Diatur oleh JS */
        }
        #main-menu h1 {
            font-size: 3em;
            color: #333;
        }
        #main-menu p {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 20px;
        }
        .menu-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        .menu-controls input {
            padding: 10px;
            font-size: 1em;
            width: 250px;
            text-align: center;
            border: 2px solid #555;
            border-radius: 5px;
        }
        
        /* --- STYLE KONTROL & KUSTOMISASI KULIT BARU --- */
        /* ... (style kontrol & kustomisasi tidak berubah) ... */
        #controls-screen h2 {
            font-size: 2em;
            color: #333;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        #controls-list {
            text-align: left;
            background-color: #fff;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            max-width: 500px;
            border: 1px solid #ddd;
        }
        #controls-list ul {
            list-style: none;
            padding-left: 0;
        }
        #controls-list li {
            font-size: 1.1em;
            margin-bottom: 12px;
        }
        #controls-list b {
            display: inline-block;
            width: 150px;
            color: #ff4500;
        }
        #controls-screen h3 {
            margin-top: 20px;
            font-size: 1.5em;
        }
        #controls-screen .tips {
            font-size: 1.1em;
            color: #444;
            max-width: 500px;
            margin-top: 10px;
        }

        #skin-customizer h2 {
            font-size: 2em;
            color: #333;
        }
        #skin-editor-area {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-top: 20px;
        }
        #skin-canvas {
            width: 300px; /* 10x10 piksel, diperbesar */
            height: 300px;
            border: 2px solid #555;
            background-color: #777;
            image-rendering: pixelated; /* Membuat piksel tetap tajam */
            cursor: crosshair;
        }
        #skin-tools {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-start;
        }
        #skin-tools label {
            font-size: 1.1em;
        }
        #skin-tools input[type="file"] {
            display: none;
        }
        .skin-tool-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #skin-load-label {
             padding: 10px 15px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border: 2px solid #555;
            border-radius: 5px;
            background-color: #fff;
            transition: background-color 0.2s, color 0.2s;
        }
         #skin-load-label:hover {
            background-color: #333;
            color: #fff;
         }


        /* --- STYLE UI GAME & EDITOR --- */
        #editor-wrapper, #controls-container {
            display: none; /* Default tersembunyi */
        }
        #editor-wrapper {
            /* BARU: Tambahkan position relative untuk menampung tombol back */
            position: relative; 
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
        }
        #game-container {
            position: relative;
        }
        #background-video {
            /* ... (style video tidak berubah) ... */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            display: none !important; 
        }
        #gameCanvas {
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
            background-size: cover;
            background-position: center;
        }
        #game-timer-display {
            /* ... (style timer tidak berubah) ... */
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            display: none; /* Default tersembunyi */
        }
        /* Tampilan Corndog BARU */
        #corndog-display {
            /* ... (style corndog tidak berubah) ... */
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px black;
            display: none; /* Default tersembunyi */
            align-items: center;
            gap: 5px;
        }
        #corndog-display img {
            width: 20px;
            height: 20px;
        }
        #controls-display {
            /* ... (style controls-display tidak berubah) ... */
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            display: none; /* Default tersembunyi */
            text-shadow: 1px 1px 2px black;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #controls-display ul {
            list-style: none;
        }
         #controls-display li {
            margin-bottom: 4px;
        }
         #controls-display b {
            display: inline-block;
            width: 110px;
            font-weight: bold;
        }
        #controls-container {
            /* ... (style controls-container tidak berubah) ... */
            margin-top: 15px;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 800px;
        }
        #controls {
            /* ... (style controls tidak berubah) ... */
            font-size: 1.2em;
            color: #333;
            background-color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            /* ... (style button tidak berubah) ... */
            padding: 10px 15px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border: 2px solid #555;
            border-radius: 5px;
            background-color: #fff;
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover, button.active {
            background-color: #333;
            color: #fff;
        }
        button:disabled {
            background-color: #ccc;
            color: #888;
            cursor: not-allowed;
            border-color: #999;
        }
        
        /* --- Tombol & Panel Editor BARU (Inventory, Settings) --- */
        /* ... (style panel editor tidak berubah) ... */
        #editor-top-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
        }
        #inventory-panel, #game-settings-panel {
            display: none; /* Default tersembunyi */
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            background-color: #ffffff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
        }
        #editor-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
            justify-content: center;
            max-width: 800px;
        }
        
        /* Panel Settings Samping (untuk object, timeline) */
        /* ... (style panel settings tidak berubah) ... */
        #settings-panel, #timeline-settings-panel {
            width: 200px;
            background: #ffffff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            display: none; /* Default tersembunyi */
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        #settings-panel h3, #timeline-settings-panel h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #settings-panel label, #timeline-settings-panel label {
            font-size: 0.9em;
        }
        #settings-panel input, #settings-panel button, #settings-panel select,
        #timeline-settings-panel input, #timeline-settings-panel button, #timeline-settings-panel select {
            width: 100%;
            padding: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-section {
            border-top: 1px solid #eee;
            padding-top: 10px;
            margin-top: 10px;
        }
        
        /* Konten Settings Game (dipindahkan) */
        /* ... (style settings game tidak berubah) ... */
        #game-settings {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
            color: #333;
            width: 100%;
        }
        .settings-slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 50%;
        }
        .background-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            width: 50%;
            justify-content: center;
        }
        .background-controls button {
            padding: 2px 5px;
            font-size: 0.8em;
            flex-basis: 45%;
         }
         
        /* --- Timeline & File --- */
        /* ... (style timeline & file tidak berubah) ... */
        #timeline-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        #timeline-header button {
            font-size: 0.8em;
            padding: 2px 5px;
        }
        #timeline-container {
            margin-top: 10px;
            width: 800px;
            text-align: center;
            color: #333;
        }
        #timeline-canvas {
            width: 100%;
            height: 60px;
            background-color: #ddd;
            border: 1px solid #555;
            cursor: pointer;
        }
        .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            padding: 0;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 50%;
            background: #f0f0f0;
        }
        .close-btn:hover {
            background: #ff4d4d;
            color: white;
            border-color: #ff4d4d;
        }
        #file-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* --- STYLE UI DALAM GAME BARU --- */
        #back-to-menu-in-game-btn {
            position: absolute;
            top: 10px;
            right: 25px; /* Disesuaikan agar tidak tumpang tindih dengan panel settings */
            z-index: 50;
            padding: 5px 10px;
            font-size: 0.9em;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #back-to-menu-in-game-btn:hover {
            background-color: #333;
            color: #fff;
        }

        /* --- STYLE LAYAR KEMATIAN BARU --- */
        #death-screen-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.9);
            display: none; /* Diaktifkan oleh JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 150;
        }
        #death-screen-overlay h2 {
            font-size: 3em;
            color: #ff4500; /* Oranye-Merah */
            text-shadow: 2px 2px 4px #000;
        }
        #death-screen-overlay button {
            width: 250px;
            font-size: 1.5em;
        }

    </style>
</head>
<body>
    <!-- PRELOADER -->
    <!-- ... (preloader tidak berubah) ... -->
    <div id="preloader">
        <div class="spinner"></div>
    </div>

    <!-- INTRO SCREEN -->
    <!-- ... (intro screen tidak berubah) ... -->
    <div id="intro-screen">
        <div id="intro-line-1" class="intro-line">I PRESENT TO Y'ALL</div>
        <div id="intro-line-2" class="intro-line">CREATED BY MaAlFa123 (LOL)</div>
    </div>

    <!-- MENU UTAMA -->
    <!-- ... (menu utama tidak berubah) ... -->
    <div id="main-menu" class="fullscreen-menu">
        <h1>Creative 2D Platformer</h1>
        <p>Create and play your own levels!</p>
        <div id="main-menu-buttons" class="menu-controls">
            <!-- Input Username BARU -->
            <input type="text" id="username-input" placeholder="Enter Username" value="Player">
            <button id="play-btn">Play</button>
            <!-- Tombol Kustomisasi Kulit BARU -->
            <button id="customize-skin-btn">Customize Skin</button>
            <!-- Tombol Kontrol BARU -->
            <button id="controls-btn">Controls & Tips</button>
        </div>
        <div id="play-submenu" class="menu-controls" style="display: none;">
            <!-- Tombol Dipisah BARU -->
            <button id="play-solo-btn">Play Level (Solo)</button>
            <button id="create-level-btn">Create Level</button>
            <button id="tutorial-btn">Tutorial</button>
            <button id="fan-level-btn" disabled>Multiplayer (WIP)</button> 
            <button id="back-to-main-btn">Back</button>
        </div>
    </div>
    
    <!-- LAYAR KONTROL BARU -->
    <!-- ... (layar kontrol tidak berubah) ... -->
    <div id="controls-screen" class="fullscreen-menu">
        <h2>Controls & Tips</h2>
        <div id="controls-list">
             <ul>
                <li><b>Move:</b> A / D</li>
                <li><b>Jump:</b> Space</li>
                <li><b>Wall Climb:</b> W (on wall)</li>
                <li><b>Sprint:</b> Hold Shift + Move</li>
                <li><b>Dash/Slide:</b> Sprint + S</li>
                <li><b>Grapple:</b> E (Aim w/ mouse)</li>
                <li><b>Set Checkpoint:</b> F (needs Corndog)</li>
                <li><b>Toggle Editor:</b> Q (in Create Mode)</li>
                <li><b>Undo:</b> Z (in Editor Mode)</li>
            </ul>
        </div>
        <h3>Pro Tips!</h3>
        <p class="tips">
            Gunakan 'Coyote Time'! Anda masih bisa melompat sesaat setelah jatuh dari pijakan.
            Gunakan lompatan dari dinding (wall-jump) dan grapple-swing untuk mencapai kecepatan tinggi!
        </p>
        <button id="back-to-main-from-controls-btn" style="margin-top: 30px;">Back</button>
    </div>
    
    <!-- LAYAR KUSTOMISASI KULIT BARU -->
    <!-- ... (layar kustomisasi kulit tidak berubah) ... -->
    <div id="skin-customizer" class="fullscreen-menu">
        <h2>Customize Your Skin</h2>
        <div id="skin-editor-area">
            <!-- Canvas 10x10, diperbesar oleh CSS -->
            <canvas id="skin-canvas" width="10" height="10"></canvas>
            <div id="skin-tools">
                <div class="skin-tool-row">
                    <label for="skin-color-picker">Draw Color:</label>
                    <input type="color" id="skin-color-picker" value="#FFFFFF">
                </div>
                 <div class="skin-tool-row">
                    <label for="skin-eraser-checkbox">Eraser:</label>
                    <input type="checkbox" id="skin-eraser-checkbox">
                </div>
                <button id="skin-save-btn">Save Skin</button>
                <input type="file" id="skin-load-input" accept="image/*">
                <label for="skin-load-input" id="skin-load-label">Load Skin</label>
            </div>
        </div>
        <button id="back-to-main-from-skin-btn" style="margin-top: 30px;">Back</button>
    </div>


    <!-- WRAPPER GAME & EDITOR -->
    <div id="editor-wrapper">
        <!-- TOMBOL KEMBALI KE MENU BARU -->
        <button id="back-to-menu-in-game-btn">Back to Menu</button>

        <div id="game-container">
            <video id="background-video" loop muted playsinline></video>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="game-timer-display">0.00</div>
            <!-- Tampilan Corndog BARU -->
            <div id="corndog-display">
                <img src="corndog.png" alt="Corndog Icon">
                <span id="corndog-count">x 0</span>
            </div>
            <div id="controls-display"></div>

            <!-- LAYAR KEMATIAN BARU -->
            <div id="death-screen-overlay">
                <h2>U DED</h2>
                <button id="death-restart-btn">Restart</button>
                <button id="death-menu-btn">Back to Menu</button>
            </div>
        </div>
        <!-- Panel Settings Samping (Object & Timeline) -->
        <!-- ... (panel settings tidak berubah) ... -->
        <div id="settings-panel">
            <button class="close-btn" id="close-settings-panel">X</button>
            <div id="object-settings-content">
                <h3>Object Settings</h3>
                <div id="general-settings">
                    <label for="color-picker">Block Color:</label>
                    <input type="color" id="color-picker">
                    <button id="rotate-btn">Rotate</button>
                    <div class="settings-row">
                         <input type="checkbox" id="transparent-checkbox">
                         <label for="transparent-checkbox">Invisible in Play Mode</label>
                    </div>
                </div>
                <div id="text-block-settings" class="settings-section" style="display: none;">
                    <h4>Text Properties</h4>
                    <label for="text-content-input">Text:</label>
                    <input type="text" id="text-content-input">
                    <label for="font-family-select">Font:</label>
                    <select id="font-family-select">
                        <option value="'Courier New', Courier, monospace">Courier New</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Times New Roman', Times, serif">Times New Roman</option>
                    </select>
                    <label for="font-size-input">Font Size:</label>
                    <input type="number" id="font-size-input" min="8" max="200">
                    <label for="text-color-picker">Text Color:</label>
                    <input type="color" id="text-color-picker" value="#FFFFFF">
                    <label for="text-glow-color-picker">Glow Color:</label>
                    <input type="color" id="text-glow-color-picker" value="#000000">
                     <label for="text-glow-size-input">Glow Size:</label>
                    <input type="number" id="text-glow-size-input" min="0" max="50" value="0">
                    <div class="settings-row">
                         <input type="checkbox" id="show-on-trigger-checkbox">
                         <label for="show-on-trigger-checkbox">Show on Trigger</label>
                    </div>
                </div>
                <div id="button-laser-settings" class="settings-section" style="display: none;">
                    <label for="laser-direction-select">Set Laser Direction:</label>
                    <select id="laser-direction-select">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                 <div id="music-block-settings" class="settings-section" style="display: none;">
                    <label for="music-block-file">Music File:</label>
                    <input type="file" id="music-block-file" accept="audio/*">
                </div>
            </div>
        </div>
        <div id="timeline-settings-panel">
            <button class="close-btn" id="close-timeline-panel">X</button>
            <div id="event-text-settings">
                <h3>Text Event</h3>
                <label for="event-text-content">Text:</label>
                <input type="text" id="event-text-content">
                <label for="event-text-size">Size:</label>
                <input type="number" id="event-text-size" value="24">
                 <label for="event-text-color">Color:</label>
                <input type="color" id="event-text-color" value="#FFFFFF">
            </div>
             <div id="event-color-settings" style="display: none;">
                <h3>Background Color Event</h3>
                <label for="event-bg-color">Target Color:</label>
                <input type="color" id="event-bg-color" value="#000000">
            </div>
        </div>
    </div>
    
    <!-- Kontrol Editor (Bawah) -->
    <!-- ... (kontrol editor tidak berubah) ... -->
    <div id="controls-container">
        <div id="controls">Press 'Q' to toggle Editor, 'Z' to Undo</div>
        
        <!-- Tombol Inventory & Settings BARU -->
        <div id="editor-top-buttons">
            <button id="inventory-toggle-btn">Inventory</button>
            <button id="settings-toggle-btn">Settings</button>
        </div>
        
        <!-- Panel Inventory BARU -->
        <div id="inventory-panel">
            <h3>Inventory</h3>
            <div id="editor-tools">
                <button class="tool-btn active" data-type="select">Select</button>
                <button class="tool-btn" data-type="platform">Platform</button>
                <button class="tool-btn" data-type="spike">Spike</button>
                <button class="tool-btn" data-type="button">Button</button>
                <button class="tool-btn" data-type="decay">Decay Block</button>
                <button class="tool-btn" data-type="delay">Delay Block</button>
                <button class="tool-btn" data-type="text_block">Text Block</button>
                <button class="tool-btn" data-type="music">Music</button>
                <button class="tool-btn" data-type="grappler">Grappler</button>
                <!-- Tombol Corndog BARU -->
                <button class="tool-btn" data-type="corndog">Corndog</button>
                <button class="tool-btn" data-type="spawn">Spawn</button>
                <button class="tool-btn" data-type="laser_source">Laser</button>
                <button class="tool-btn" data-type="end">End</button>
                <button class="tool-btn" id="link-tool-btn" data-type="linker">Link</button>
            </div>
        </div>
        
        <!-- Panel Settings Game BARU (dipindahkan ke sini) -->
        <div id="game-settings-panel">
            <h3>Game Settings</h3>
            <div id="game-settings">
                 <div class="settings-slider-row">
                    <label for="laser-speed-slider">Laser Speed:</label>
                    <input type="range" id="laser-speed-slider" min="0.5" max="10" step="0.1" value="1.5">
                </div>
                 <div class="settings-slider-row">
                    <label for="platform-speed-slider">Platform Speed:</label>
                    <input type="range" id="platform-speed-slider" min="0.5" max="10" step="0.1" value="2">
                </div>
                 <div class="settings-slider-row">
                    <label for="player-speed-slider">Player Speed:</label>
                    <input type="range" id="player-speed-slider" min="1" max="15" step="0.1" value="5">
                </div>
                 <div class="settings-slider-row">
                     <label for="player-accel-slider">Player Accel:</label>
                    <input type="range" id="player-accel-slider" min="0.1" max="2" step="0.05" value="0.4">
                </div>
                 <div class="settings-slider-row">
                    <label for="player-jump-slider">Player Jump:</label>
                    <input type="range" id="player-jump-slider" min="5" max="25" step="0.5" value="13">
                </div>
                 <div class="settings-slider-row">
                    <label for="background-color-picker">BG Color:</label>
                    <input type="color" id="background-color-picker" value="#000000">
                </div>
                <div class="background-controls">
                    <button id="set-background-image-btn">Set BG Image</button>
                    <input type="file" id="background-image-input" accept="image/*" style="display: none;">
                    <button id="set-background-video-btn">Set BG Video</button>
                    <input type="file" id="background-video-input" accept="video/*" style="display: none;">
                    <button id="clear-background-btn">Clear Background</button>
                </div>
                <div class="settings-slider-row">
                    <label for="hook-enabled-checkbox">Grappling Hook:</label>
                    <input type="checkbox" id="hook-enabled-checkbox">
                </div>
            </div>
        </div>
        
        <!-- Timeline & File Controls (tetap) -->
        <!-- ... (timeline & file controls tidak berubah) ... -->
        <div id="timeline-container">
            <div id="timeline-header">
                <label>Timeline:</label>
                <button id="add-text-event-btn">Add Text Event</button>
                <button id="add-color-event-btn">Add Color Event</button>
            </div>
            <canvas id="timeline-canvas" width="800" height="60"></canvas>
        </div>
        <div id="file-controls">
            <button id="saveButton">Save Level</button>
            <button id="loadButton">Load Level</button>
            <!-- TOMBOL HAPUS BARU -->
            <button id="clearAllButton" style="background-color: #ff4d4d; color: white; border-color: #ff4d4d;">Clear All</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
    </div>
    
    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const backgroundVideo = document.getElementById('background-video');
        const gameTimerDisplay = document.getElementById('game-timer-display');
        // Tampilan Corndog BARU
        const corndogDisplay = document.getElementById('corndog-display');
        const corndogCountSpan = document.getElementById('corndog-count');
        
        // UI BARU
        const deathScreenOverlay = document.getElementById('death-screen-overlay');
        const deathRestartBtn = document.getElementById('death-restart-btn');
        const deathMenuBtn = document.getElementById('death-menu-btn');
        const backToMenuInGameBtn = document.getElementById('back-to-menu-in-game-btn');
        
        const controlsDisplay = document.getElementById('controls-display');
        const timelineCanvas = document.getElementById('timeline-canvas');
        const timelineCtx = timelineCanvas.getContext('2d');
        const controlsText = document.getElementById('controls');
        const toolButtons = document.querySelectorAll('.tool-btn');
        
        // Panel Settings Samping
        // ... (referensi panel settings tidak berubah) ...
        const settingsPanel = document.getElementById('settings-panel');
        const objectSettingsContent = document.getElementById('object-settings-content');
        const colorPicker = document.getElementById('color-picker');
        const rotateBtn = document.getElementById('rotate-btn');
        const transparentCheckbox = document.getElementById('transparent-checkbox');
        
        // Settings Text Block
        const textBlockSettingsDiv = document.getElementById('text-block-settings');
        const textContentInput = document.getElementById('text-content-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorPicker = document.getElementById('text-color-picker');
        const textGlowColorPicker = document.getElementById('text-glow-color-picker');
        const textGlowSizeInput = document.getElementById('text-glow-size-input');
        const showOnTriggerCheckbox = document.getElementById('show-on-trigger-checkbox');

        // Settings Object Lain
        const buttonLaserSettingsDiv = document.getElementById('button-laser-settings');
        const laserDirectionSelect = document.getElementById('laser-direction-select');
        const musicBlockSettingsDiv = document.getElementById('music-block-settings');
        const musicBlockFileInput = document.getElementById('music-block-file');
        
        // Settings Game (Slider, dll)
        // ... (referensi settings game tidak berubah) ...
        const laserSpeedSlider = document.getElementById('laser-speed-slider');
        const platformSpeedSlider = document.getElementById('platform-speed-slider');
        const playerSpeedSlider = document.getElementById('player-speed-slider');
        const playerAccelSlider = document.getElementById('player-accel-slider');
        const playerJumpSlider = document.getElementById('player-jump-slider');
        const hookEnabledCheckbox = document.getElementById('hook-enabled-checkbox');
        
        // Settings Background
        const backgroundColorPicker = document.getElementById('background-color-picker');
        const setBackgroundImageBtn = document.getElementById('set-background-image-btn');
        const backgroundImageInput = document.getElementById('background-image-input');
        const setBackgroundVideoBtn = document.getElementById('set-background-video-btn');
        const backgroundVideoInput = document.getElementById('background-video-input');
        const clearBackgroundBtn = document.getElementById('clear-background-btn');
        
        // Timeline
        // ... (referensi timeline tidak berubah) ...
        const timelineSettingsPanel = document.getElementById('timeline-settings-panel');
        const eventTextSettingsDiv = document.getElementById('event-text-settings');
        const eventTextContentInput = document.getElementById('event-text-content');
        const eventTextSizeInput = document.getElementById('event-text-size');
        const eventTextColorInput = document.getElementById('event-text-color');
        const eventColorSettingsDiv = document.getElementById('event-color-settings');
        const eventBgColorInput = document.getElementById('event-bg-color');
        const addTextEventBtn = document.getElementById('add-text-event-btn');
        const addColorEventBtn = document.getElementById('add-color-event-btn');
        const closeSettingsPanelBtn = document.getElementById('close-settings-panel');
        const closeTimelinePanelBtn = document.getElementById('close-timeline-panel');
        
        // Kontrol File
        // ... (referensi kontrol file tidak berubah) ...
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const importFileInput = document.getElementById('import-file-input');
        // TOMBOL HAPUS BARU
        const clearAllButton = document.getElementById('clearAllButton');
        
        // Menu Utama & Submenu
        // ... (referensi menu tidak berubah) ...
        const mainMenu = document.getElementById('main-menu');
        const mainMenuButtons = document.getElementById('main-menu-buttons');
        const playSubMenu = document.getElementById('play-submenu');
        const createLevelBtn = document.getElementById('create-level-btn'); // Ganti nama dari soloBtn
        const playSoloBtn = document.getElementById('play-solo-btn'); // Tombol BARU
        const playBtn = document.getElementById('play-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const backToMainBtn = document.getElementById('back-to-main-btn');
        // Input Username BARU
        const usernameInput = document.getElementById('username-input');

        // Tombol & Layar BARU
        // ... (referensi tombol & layar tidak berubah) ...
        const controlsBtn = document.getElementById('controls-btn');
        const controlsScreen = document.getElementById('controls-screen');
        const backToMainFromControlsBtn = document.getElementById('back-to-main-from-controls-btn');
        const customizeSkinBtn = document.getElementById('customize-skin-btn');
        const skinCustomizer = document.getElementById('skin-customizer');
        const backToMainFromSkinBtn = document.getElementById('back-to-main-from-skin-btn');
        
        // Kontrol Editor BARU
        // ... (referensi kontrol editor tidak berubah) ...
        const inventoryToggleBtn = document.getElementById('inventory-toggle-btn');
        const settingsToggleBtn = document.getElementById('settings-toggle-btn');
        const inventoryPanel = document.getElementById('inventory-panel');
        const gameSettingsPanel = document.getElementById('game-settings-panel');
        
        // Kustomisasi Kulit BARU
        // ... (referensi kustomisasi kulit tidak berubah) ...
        const skinCanvas = document.getElementById('skin-canvas');
        const skinCtx = skinCanvas.getContext('2d');
        const skinColorPicker = document.getElementById('skin-color-picker');
        const skinEraserCheckbox = document.getElementById('skin-eraser-checkbox');
        const skinSaveBtn = document.getElementById('skin-save-btn');
        const skinLoadInput = document.getElementById('skin-load-input');
        let playerSkinImage = new Image();
        let playerSkinDataUrl = null;
        let isDrawingSkin = false;

        // --- STATE GAME ---
        let editorMode = false;
        let isPlayOnlyMode = false;
        let loadMode = 'editor'; // BARU: 'editor' atau 'play'
        const gridSize = 20;
        const editorCameraSpeed = 10;
        const TIMELINE_MAX_SECONDS = 300;

        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let mouseX = 0, mouseY = 0;
        let currentBlockType = 'select';
        let linkingState = { isLinking: false, sourceButtonId: null };
        let pathCreationState = { isCreating: false, sourceObjectId: null };
        let isSelectionRotated = false;
        let selectedObjectId = null;
        let gameWon = false;
        let gameTime = 0;
        
        let activeAudio = {};
        let levelBackgroundImage = null;

        let selectedTimelineEventId = null;
        let currentTimelineEventType = 'text';
        let timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        
        const worldWidth = 4000;
        const worldHeight = 20000;
        const gravity = 0.6;
        const MAX_JUMPS = 2;
        const JUMP_BUFFER_FRAMES = 8;
        // Coyote Time BARU - DIUBAH MENJADI 1 DETIK (60 frame)
        // const COYOTE_TIME_FRAMES = 60; // --- MOD --- Dihapus
        const COYOTE_TIME_FRAMES_NORMAL = 60; // 1 detik (sesuai kode Anda)
        const COYOTE_TIME_FRAMES_WALLJUMP = 90; // 1.5 detik (bonus setelah wall jump)
        
        const DELAY_BLOCK_FADE_TIME = 300; 

        // State Corndog BARU
        let corndogImage = new Image();
        corndogImage.src = 'corndog.png'; // Pastikan file ini ada
        let corndogCount = 0;
        let checkpointPosition = null;

        let history = [];
        let historyIndex = -1;

        // --- STATE PEMAIN & KEMATIAN BARU ---
        let playerState = 'alive'; // 'alive', 'dying', 'dead'
        let deathTimer = 0;
        const DEATH_ANIM_DURATION = 90; // 90 frame @ 60fps ~= 1.5 detik
        let shatterParticles = [];

        function saveState() {
            // ... (fungsi saveState tidak berubah) ...
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const savableObjects = JSON.parse(JSON.stringify(levelObjects));
            history.push(JSON.stringify({ objects: savableObjects, settings: levelSettings }));
            historyIndex++;
        }

        function undo() {
            // ... (fungsi undo tidak berubah) ...
            if (historyIndex > 0) {
                historyIndex--;
                const previousState = JSON.parse(history[historyIndex]);
                levelObjects = previousState.objects;
                levelSettings = previousState.settings;
                laserSpeedSlider.value = levelSettings.laserSpeed;
                platformSpeedSlider.value = levelSettings.platformSpeed;
                playerSpeedSlider.value = levelSettings.playerMaxSpeed;
                playerAccelSlider.value = levelSettings.playerAcceleration;
                playerJumpSlider.value = levelSettings.playerJumpPower;
                backgroundColorPicker.value = levelSettings.backgroundColor || '#000000';
                hookEnabledCheckbox.checked = levelSettings.hookEnabled || false;
                loadBackgroundMedia();
                applySettingsToPlayer();
                drawTimeline();
            }
        }
        
        const playerStart = { x: 50, y: worldHeight - 60 };
        const player = {
            // ... (objek player tidak berubah) ...
            x: playerStart.x, y: playerStart.y, width: 40, height: 40,
            originalHeight: 40, velocityX: 0, velocityY: 0, jumpPower: 13,
            jumpsMade: 0, color: '#FFFFFF', acceleration: 0.4, friction: 0.3,
            maxSpeed: 5, isWallHolding: false, 
            wallClimbAcceleration: 0.2, maxWallClimbSpeed: 2.5, wallClimbFriction: 0.3,
            coyoteTimeCounter: 0, // Diperbarui
            wallDirection: 0, isCrouching: false, isDashing: false, 
            dashSpeed: 0, dashFriction: 0.2, isSprinting: false, 
            sprintMultiplier: 1.6,
            hasHook: false, 
            lastAction: 'landed', // --- NEW --- 'landed', 'jump', 'walljump'
            username: 'Player'
        };

        let levelObjects = [
            // ... (levelObjects default tidak berubah) ...
            { id: Date.now(), type: 'platform', x: 0, y: worldHeight - 20, width: worldWidth, height: 20, color: '#999999', isSolid: true },
        ];
        
        let levelSettings = {
            // ... (levelSettings tidak berubah) ...
            laserSpeed: 1.5,
            platformSpeed: 2,
            playerMaxSpeed: 5,
            playerAcceleration: 0.4,
            playerJumpPower: 13,
            timelineEvents: [],
            backgroundColor: '#000000',
            backgroundImageSrc: null,
            backgroundVideoSrc: null,
            hookEnabled: false,
        };
        
        let hookState = {
            // ... (state hook tidak berubah) ...
            isFiring: false,
            isHooked: false,
            x: 0, y: 0,
            velocityX: 0, velocityY: 0,
            startX: 0, startY: 0,
            ropeLength: 0,
            maxLength: 500,
            speed: 30,
            attachedObjectId: null,
        };

        const camera = { x: 0, y: 0 };
        const keys = { w: false, a: false, s: false, d: false, shift: false, space: false, f: false }; // 'f' ditambahkan
        let jumpBufferCounter = 0;

        function applySettingsToPlayer() {
            // ... (fungsi applySettingsToPlayer tidak berubah) ...
            player.maxSpeed = levelSettings.playerMaxSpeed;
            player.acceleration = levelSettings.playerAcceleration;
            player.jumpPower = levelSettings.playerJumpPower;
        }

        function checkRectCollision(objA, objB) {
            // ... (fungsi checkRectCollision tidak berubah) ...
            return objA.x < objB.x + objB.width && objA.x + objA.width > objB.x && objA.y < objB.y + objB.height && objA.y + objA.height > objB.y;
        }
        
        // ... (fungsi sign & isPointInTriangle tidak berubah) ...
        function sign(p1, p2, p3) { return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y); }
        function isPointInTriangle(pt, v1, v2, v3) {
            const d1 = sign(pt, v1, v2), d2 = sign(pt, v2, v3), d3 = sign(pt, v3, v1);
            const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0), has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
            return !(has_neg && has_pos);
        }
        function checkPlayerSpikeCollision(player, spike) {
            // ... (fungsi checkPlayerSpikeCollision tidak berubah) ...
            if (!checkRectCollision(player, spike)) return false; 
            const playerCorners = [ { x: player.x, y: player.y }, { x: player.x + player.width, y: player.y }, { x: player.x, y: player.y + player.height }, { x: player.x + player.width, y: player.y + player.height }, ];
            let v1, v2, v3;
            const o = spike.orientation || 'up';
            if (o === 'up') { v1 = { x: spike.x, y: spike.y + spike.height }; v2 = { x: spike.x + spike.width / 2, y: spike.y }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height }; } 
            else if (o === 'down') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y }; v3 = { x: spike.x + spike.width / 2, y: spike.y + spike.height }; } 
            else if (o === 'left') { v1 = { x: spike.x + spike.width, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y + spike.height }; v3 = { x: spike.x, y: spike.y + spike.height / 2 }; } 
            else if (o === 'right') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x, y: spike.y + spike.height }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height / 2 }; }
            // PERUBAHAN: Panggil triggerPlayerDeath alih-alih resetPlayer
            const collided = playerCorners.some(corner => isPointInTriangle(corner, v1, v2, v3));
            if (collided) {
                triggerPlayerDeath(); // MEMICU KEMATIAN
                return true;
            }
            return false;
        }

        // FUNGSI resetPlayer DIGANTI NAMA MENJADI respawnPlayer
        // ... (fungsi respawnPlayer tidak berubah) ...
        function respawnPlayer() {
            gameWon = false;
            gameTime = 0;
            player.hasHook = false; 
            applySettingsToPlayer();
            detachHook();
            
            Object.values(activeAudio).forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });

            // Logika Checkpoint DIPERBARUI
            let spawnPoint = levelObjects.find(obj => obj.type === 'spawn');
            
            // Checkpoint SEKARANG PERSISTEN. Tidak di-reset ke null.
            const startPos = checkpointPosition || (spawnPoint ? {x: spawnPoint.x, y: spawnPoint.y} : playerStart);
            
            // Bendera tidak lagi dihapus saat respawn, hanya saat bendera baru ditanam
            
            // Reset semua object level
            // ... (logika reset objek tidak berubah) ...
            levelObjects.forEach(obj => { 
                if(obj.movePath) { obj.x = obj.movePath.start.x; obj.y = obj.movePath.start.y; obj.moveDirection = 1; }
                if(obj.type === 'button') obj.activated = false;
                if(obj.type === 'decay') obj.phased = false;
                if(obj.type === 'delay') { obj.phased = false; obj.delayTimer = 0; obj.isFading = false; }
                if(obj.type === 'laser_source') {
                    clearTimeout(obj.activationTimeout);
                    obj.isActive = false;
                }
                if(obj.type === 'grappler') { obj.visible = false; obj.collected = false; }
            });
            
            // corndogCount TIDAK di-reset di sini
            // obj.collected TIDAK di-reset di sini
            updateCorndogDisplay();
            
            Object.assign(player, { x: startPos.x, y: startPos.y, velocityX: 0, velocityY: 0, jumpsMade: 0, isDashing: false, isWallHolding: false, coyoteTimeCounter: 0, isCrouching: false, height: player.originalHeight });

            // Snap kamera instan
            camera.x = player.x - canvas.width / 2 + player.width / 2;
            camera.y = player.y - canvas.height / 2 + player.height / 2;
            
            // Sembunyikan UI Kematian & reset state (BARU)
            playerState = 'alive';
            deathTimer = 0;
            shatterParticles = [];
            deathScreenOverlay.style.display = 'none';
        }
        
        // FUNGSI KEMATIAN BARU
        // ... (fungsi triggerPlayerDeath tidak berubah) ...
        function triggerPlayerDeath() {
            if (playerState !== 'alive' || isPlayOnlyMode === false) return; // Hanya mati di mode 'play'
            
            playerState = 'dying';
            deathTimer = 0;
            shatterParticles = [];
            
            // Buat partikel pecah
            for (let i = 0; i < 50; i++) {
                shatterParticles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    width: Math.random() * 6 + 2,
                    height: Math.random() * 6 + 2,
                    velocityX: (Math.random() - 0.5) * 8, // Disesuaikan untuk 60fps
                    velocityY: (Math.random() - 0.5) * 15 - 5, // Dorongan ke atas
                    color: '#ff4500' // Merah-Oranye
                });
            }
        }
        
        // FUNGSI MENU UTAMA BARU
        // ... (fungsi goToMainMenu tidak berubah) ...
        function goToMainMenu() {
            document.getElementById('editor-wrapper').style.display = 'none';
            document.getElementById('controls-container').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            
            // Sembunyikan submenu & layar lain
            playSubMenu.style.display = 'none';
            mainMenuButtons.style.display = 'flex';
            controlsScreen.style.display = 'none';
            skinCustomizer.style.display = 'none';
            deathScreenOverlay.style.display = 'none';
            
            // Stop semua audio
            Object.values(activeAudio).forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
            
            // Reset state game
            editorMode = false;
            isPlayOnlyMode = false;
            gameWon = false;
            playerState = 'alive';
            checkpointPosition = null; // PENTING: Reset checkpoint saat kembali ke menu
        }

        function canStandUp() {
            // ... (fungsi canStandUp tidak berubah) ...
            const standHitbox = { x: player.x, y: player.y - player.originalHeight / 2, width: player.width, height: player.originalHeight };
            return !levelObjects.some(obj => obj.isSolid && obj.type === 'platform' && checkRectCollision(standHitbox, obj));
        }
        
        function keyDownHandler(e) {
            const key = e.key.toLowerCase();
            
            // Cek jika fokus ada di input teks
            // ... (logika fokus input tidak berubah) ...
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return; // Jangan proses hotkey jika sedang mengetik
            }
            
            if (key === 'z' && editorMode) {
                undo();
                return;
            }
            if (key === 'q' && !isPlayOnlyMode) { 
                editorMode = !editorMode;
                gameTimerDisplay.style.display = editorMode ? 'none' : 'block';
                corndogDisplay.style.display = editorMode ? 'none' : 'flex'; // Tampilkan corndog
                controlsDisplay.style.display = editorMode ? 'none' : 'block';
                controlsText.textContent = editorMode ? "EDITOR MODE [W,A,S,D to Pan | Q to Toggle]" : "PLAY MODE";
                if (!editorMode) { 
                    selectedObjectId = null; selectedTimelineEventId = null; updateSettingsPanel(); updateTimelineSettingsPanel(); 
                    respawnPlayer(); // Panggil respawnPlayer, BUKAN triggerDeath
                } else {
                    Object.values(activeAudio).forEach(audio => audio.pause());
                }
                return;
            }
            if (key === 'r' && editorMode) { isSelectionRotated = !isSelectionRotated; return; }
            
            // Jangan terima input gameplay jika tidak hidup
            if (playerState !== 'alive') return; 

            // Gameplay Keys
            // ... (sisa logika keydown tidak berubah) ...
            if (key === 'd') keys.d = true;
            else if (key === 'a') keys.a = true;
            else if (key === 's') keys.s = true;
            else if (key === 'shift') keys.shift = true;
            else if (key === 'w') keys.w = true; // Untuk memanjat / grapple
            else if (key === 'f') keys.f = true; // Kunci Corndog BARU
            else if (key === ' ') {
                e.preventDefault();
                keys.space = true;
                jumpBufferCounter = JUMP_BUFFER_FRAMES;
                
                // --- LOGIKA JUMP BARU (dgn Coyote Time & Wall Jump) ---
                if (!e.repeat && !editorMode) {
                    if (player.coyoteTimeCounter > 0 || (player.isWallHolding && !onGround)) { // Lompat dasar, coyote, atau lompat dinding
                        player.velocityY = -player.jumpPower;
                        
                        // BARU: Reset lompatan saat wall-jump, tapi hitung sbg 1 saat lompat biasa
                        if (player.isWallHolding) {
                            player.jumpsMade = 0; // RESET jumps on wall jump
                            player.lastAction = 'walljump'; // --- NEW --- Catat wall jump
                        } else {
                            player.jumpsMade = 1; // Normal ground/coyote jump
                            player.lastAction = 'jump'; // --- NEW --- Catat lompatan normal
                        }
                        
                        jumpBufferCounter = 0;
                        player.coyoteTimeCounter = 0;
                        if (player.isWallHolding) {
                            player.velocityX = -player.wallDirection * player.jumpPower * 0.75; // Dorongan dari dinding
                            player.isWallHolding = false;
                        }
                    } else if (!player.isWallHolding && !hookState.isHooked && player.jumpsMade > 0 && player.jumpsMade < MAX_JUMPS) { // Double jump
                        player.velocityY = -player.jumpPower;
                        player.jumpsMade++; // <--- INCREMENTS JUMPS
                        jumpBufferCounter = 0;
                    }
                }
            } else if (key === 'e' && !editorMode && levelSettings.hookEnabled && player.hasHook && !e.repeat) {
                e.preventDefault();
                if (hookState.isHooked) {
                    detachHook();
                } else if (!hookState.isFiring) {
                    fireHook();
                }
            }
        }

        function keyUpHandler(e) {
            // ... (logika keyup tidak berubah) ...
            const key = e.key.toLowerCase();
            if (key === 'd') keys.d = false;
            else if (key === 'a') keys.a = false;
            else if (key === 's') keys.s = false;
            else if (key === 'w') keys.w = false;
            else if (key === ' ') keys.space = false;
            else if (key === 'shift') keys.shift = false;
            else if (key === 'f') keys.f = false; // Kunci Corndog BARU
        }
        
        function updateMousePos(e) {
            // ... (fungsi updateMousePos tidak berubah) ...
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left + camera.x;
            mouseY = e.clientY - rect.top + camera.y;
        }

        function updateSettingsPanel() {
            // ... (fungsi updateSettingsPanel tidak berubah) ...
            const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
            
            textBlockSettingsDiv.style.display = 'none';
            buttonLaserSettingsDiv.style.display = 'none';
            musicBlockSettingsDiv.style.display = 'none';
            objectSettingsContent.style.display = 'none';
            
            if (editorMode) {
                 if (selectedObject) {
                    settingsPanel.style.display = 'flex';
                    objectSettingsContent.style.display = 'block';
                    colorPicker.value = selectedObject.color || '#999999';
                    transparentCheckbox.checked = selectedObject.isSolid === false;

                    if (selectedObject.type === 'text_block') {
                        textBlockSettingsDiv.style.display = 'block';
                        textContentInput.value = selectedObject.content || '';
                        fontSizeInput.value = selectedObject.fontSize || 32;
                        fontFamilySelect.value = selectedObject.fontFamily || "'Courier New', Courier, monospace";
                        textColorPicker.value = selectedObject.textColor || '#FFFFFF';
                        textGlowColorPicker.value = selectedObject.glowColor || '#000000';
                        textGlowSizeInput.value = selectedObject.glowSize || 0;
                        showOnTriggerCheckbox.checked = selectedObject.showOnTrigger || false;
                    }
                     if (selectedObject.type === 'music') {
                        musicBlockSettingsDiv.style.display = 'block';
                    }
                    if (selectedObject.type === 'button' && selectedObject.linkedTo && selectedObject.linkedTo.some(id => {
                        const linked = levelObjects.find(o => o.id === id);
                        return linked && linked.type === 'laser_source';
                    })) {
                        buttonLaserSettingsDiv.style.display = 'block';
                        laserDirectionSelect.value = selectedObject.laserLinkDirection || 'left';
                    }
                } else {
                    settingsPanel.style.display = 'none';
                }
            } else {
                settingsPanel.style.display = 'none';
            }
        }
        
        function updateTimelineSettingsPanel() {
            // ... (fungsi updateTimelineSettingsPanel tidak berubah) ...
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            eventTextSettingsDiv.style.display = 'none';
            eventColorSettingsDiv.style.display = 'none';

            if(event && editorMode) {
                timelineSettingsPanel.style.display = 'flex';
                if (event.type === 'text') {
                    eventTextSettingsDiv.style.display = 'block';
                    eventTextContentInput.value = event.text || '';
                    eventTextSizeInput.value = event.fontSize || 24;
                    eventTextColorInput.value = event.color || '#FFFFFF';
                } else if (event.type === 'background_color') {
                    eventColorSettingsDiv.style.display = 'block';
                    eventBgColorInput.value = event.color || '#000000';
                }
            } else {
                timelineSettingsPanel.style.display = 'none';
            }
        }
        
        function mouseDownHandler(e) {
            // ... (logika mousedown tidak berubah) ...
            if (!editorMode) return;
            e.preventDefault();
            updateMousePos(e);

            const clickedObject = levelObjects.find(obj => mouseX >= obj.x && mouseX <= obj.x + obj.width && mouseY >= obj.y && mouseY <= obj.y + obj.height);

            if (linkingState.isLinking) {
                // ... (logika linking tidak berubah) ...
                if (!clickedObject) return;
                if (clickedObject.type === 'button' && !linkingState.sourceButtonId) {
                    linkingState.sourceButtonId = clickedObject.id;
                } else if ((['decay', 'end', 'laser_source', 'music', 'text_block', 'grappler'].includes(clickedObject.type)) && linkingState.sourceButtonId) {
                    const sourceButton = levelObjects.find(obj => obj.id === linkingState.sourceButtonId);
                    if (sourceButton) {
                        if (!sourceButton.linkedTo) sourceButton.linkedTo = [];
                        if (!sourceButton.linkedTo.includes(clickedObject.id)) {
                             sourceButton.linkedTo.push(clickedObject.id);
                        }
                    }
                    linkingState.sourceButtonId = null; 
                    saveState();
                }
                return;
            }

            if (e.button === 0) { // Left Click
                // ... (logika mousedown tidak berubah) ...
                if (currentBlockType === 'select') {
                    selectedObjectId = clickedObject ? clickedObject.id : null;
                    selectedTimelineEventId = null;
                    if (clickedObject) {
                        pathCreationState.isCreating = true;
                        pathCreationState.sourceObjectId = clickedObject.id;
                    }
                    updateSettingsPanel();
                    updateTimelineSettingsPanel();
                } else { // Creation mode
                    selectedObjectId = null; updateSettingsPanel();
                    isDragging = true;
                    dragStartX = Math.floor(mouseX / gridSize) * gridSize;
                    dragStartY = Math.floor(mouseY / gridSize) * gridSize;
                }
            } else if (e.button === 2) { 
                if (clickedObject) {
                    if (clickedObject.movePath) { delete clickedObject.movePath; saveState(); } 
                    else {
                        levelObjects = levelObjects.filter(p => p.id !== clickedObject.id);
                        if (selectedObjectId === clickedObject.id) { selectedObjectId = null; updateSettingsPanel(); }
                        saveState();
                    }
                }
            }
        }

        function mouseUpHandler(e) {
            // ... (logika mouseup tidak berubah) ...
            if (!editorMode) return;
            if (pathCreationState.isCreating) { 
                // ... (logika path creation tidak berubah) ...
                const sourceObject = levelObjects.find(obj => obj.id === pathCreationState.sourceObjectId);
                if (sourceObject) {
                    const dx = mouseX - (sourceObject.x + sourceObject.width / 2);
                    const dy = mouseY - (sourceObject.y + sourceObject.height / 2);
                    if (dx*dx + dy*dy > 100) { 
                        sourceObject.movePath = { 
                            start: { x: sourceObject.x, y: sourceObject.y }, 
                            end: { x: mouseX - sourceObject.width / 2, y: mouseY - sourceObject.height / 2 } 
                        };
                        sourceObject.moveSpeed = parseFloat(platformSpeedSlider.value); 
                        sourceObject.moveDirection = 1;
                        saveState();
                    }
                }
                pathCreationState.isCreating = false; 
                pathCreationState.sourceObjectId = null;
                return;
            }

            if (!isDragging || linkingState.isLinking) return;
            isDragging = false;
            const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
            const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
            let width = Math.abs(endX - dragStartX), height = Math.abs(endY - dragStartY);
            if (isSelectionRotated) [width, height] = [height, width];
            const newObject = {
                id: Date.now() + Math.random(), type: currentBlockType,
                x: Math.min(dragStartX, endX), y: Math.min(dragStartY, endY),
                width: width, height: height, color: '#999999', isSolid: true
            };
            if (newObject.width > 0 && newObject.height > 0) {
                 if(['spawn', 'end'].includes(newObject.type)){
                    levelObjects = levelObjects.filter(o => o.type !== newObject.type); 
                    newObject.width = gridSize; newObject.height = gridSize;
                    if(newObject.type === 'spawn') newObject.color = '#00e676';
                    if(newObject.type === 'end') newObject.color = '#8e24aa';
                 }
                 if(newObject.type === 'laser_source') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#ffa500'; newObject.orientation = 'left';
                    newObject.isActive = false; newObject.position = 0;
                 }
                  if(newObject.type === 'music') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#3399ff'; newObject.isSolid = false;
                 }
                 if(newObject.type === 'grappler') {
                    newObject.width = gridSize * 2; newObject.height = gridSize * 2;
                    newObject.color = '#9c27b0'; newObject.isSolid = false;
                    newObject.visible = false; newObject.collected = false;
                 }
                 // Penambahan Corndog BARU
                 if(newObject.type === 'corndog') {
                    newObject.width = gridSize * 2; newObject.height = gridSize * 2;
                    newObject.color = '#FFD700'; // Warna fallback jika gambar gagal
                    newObject.isSolid = false;
                    newObject.collected = false;
                 }
                 if(newObject.type === 'text_block') {
                    newObject.content = "Text";
                    newObject.fontSize = 32;
                    newObject.fontFamily = "'Courier New', Courier, monospace";
                    newObject.textColor = '#FFFFFF';
                    newObject.glowColor = '#000000';
                    newObject.glowSize = 0;
                    newObject.color = '#333333';
                    newObject.isSolid = false;
                    newObject.showOnTrigger = false;
                    newObject.visible = true;
                 }
                 if(newObject.type === 'button') { newObject.activated = false; newObject.color = '#ff0000'; }
                 if(newObject.type === 'decay') { newObject.phased = false; newObject.color = '#444444'; }
                 if(newObject.type === 'delay') { newObject.phased = false; newObject.delayTimer = 0; newObject.color = '#666666'; newObject.isFading = false; }
                 if(newObject.type === 'spike') { newObject.color = '#ff0000'; newObject.orientation = 'up'; }
                 levelObjects.push(newObject);
                 saveState();
            }
        }

        toolButtons.forEach(button => {
            // ... (listener toolButtons tidak berubah) ...
            button.addEventListener('click', () => {
                toolButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentBlockType = button.dataset.type;
                linkingState.isLinking = currentBlockType === 'linker';
                linkingState.sourceButtonId = null;
                isSelectionRotated = false;
            });
        });
        
        colorPicker.addEventListener('input', (e) => {
            // ... (listener colorPicker tidak berubah) ...
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.color = e.target.value; saveState(); }
            }
        });

        transparentCheckbox.addEventListener('change', (e) => {
            // ... (listener transparentCheckbox tidak berubah) ...
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.isSolid = !e.target.checked; saveState(); }
            }
        });
        
        // --- TEXT BLOCK SETTINGS LISTENERS ---
        // ... (listener settings text block tidak berubah) ...
        function updateSelectedTextBlock(prop, value) {
             // ... (fungsi updateSelectedTextBlock tidak berubah) ...
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'text_block') {
                    selectedObject[prop] = value;
                    saveState();
                }
            }
        }
        textContentInput.addEventListener('input', (e) => updateSelectedTextBlock('content', e.target.value));
        fontSizeInput.addEventListener('input', (e) => updateSelectedTextBlock('fontSize', parseInt(e.target.value, 10)));
        fontFamilySelect.addEventListener('change', (e) => updateSelectedTextBlock('fontFamily', e.target.value));
        textColorPicker.addEventListener('input', (e) => updateSelectedTextBlock('textColor', e.target.value));
        textGlowColorPicker.addEventListener('input', (e) => updateSelectedTextBlock('glowColor', e.target.value));
        textGlowSizeInput.addEventListener('input', (e) => updateSelectedTextBlock('glowSize', parseInt(e.target.value, 10)));
        showOnTriggerCheckbox.addEventListener('change', (e) => {
            // ... (listener showOnTriggerCheckbox tidak berubah) ...
            const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
            if (selectedObject && selectedObject.type === 'text_block') {
                selectedObject.showOnTrigger = e.target.checked;
                if(selectedObject.showOnTrigger) {
                    selectedObject.visible = false;
                }
                saveState();
            }
        });

        laserDirectionSelect.addEventListener('change', (e) => {
             // ... (listener laserDirectionSelect tidak berubah) ...
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'button') {
                    selectedObject.laserLinkDirection = e.target.value;
                    saveState();
                }
            }
        });

        musicBlockFileInput.addEventListener('change', (e) => {
            // ... (listener musicBlockFileInput tidak berubah) ...
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                const file = e.target.files[0];
                if (selectedObject && selectedObject.type === 'music' && file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const dataUrl = event.target.result;
                        selectedObject.musicSrc = dataUrl;

                        const audio = new Audio(dataUrl);
                        audio.loop = true;
                        activeAudio[selectedObject.id] = audio;
                        saveState();
                    }
                    reader.readAsDataURL(file);
                }
            }
        });
        
        rotateBtn.addEventListener('click', () => {
             // ... (listener rotateBtn tidak berubah) ...
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    if (selectedObject.type === 'spike' || selectedObject.type === 'laser_source') {
                        const orientations = ['up', 'right', 'down', 'left'];
                        const currentIndex = orientations.indexOf(selectedObject.orientation || 'up');
                        selectedObject.orientation = orientations[(currentIndex + 1) % 4];
                    } else {
                        [selectedObject.width, selectedObject.height] = [selectedObject.height, selectedObject.width];
                    }
                    saveState();
                }
            }
        });
        
        // ... (listener slider settings game tidak berubah) ...
        laserSpeedSlider.addEventListener('input', (e) => { levelSettings.laserSpeed = parseFloat(e.target.value); });
        platformSpeedSlider.addEventListener('input', (e) => { levelSettings.platformSpeed = parseFloat(e.target.value); });
        playerSpeedSlider.addEventListener('input', (e) => { levelSettings.playerMaxSpeed = parseFloat(e.target.value); applySettingsToPlayer(); });
        playerAccelSlider.addEventListener('input', (e) => { levelSettings.playerAcceleration = parseFloat(e.target.value); applySettingsToPlayer(); });
        playerJumpSlider.addEventListener('input', (e) => { levelSettings.playerJumpPower = parseFloat(e.target.value); applySettingsToPlayer(); });
        
        laserSpeedSlider.addEventListener('change', saveState);
        platformSpeedSlider.addEventListener('change', saveState);
        playerSpeedSlider.addEventListener('change', saveState);
        playerAccelSlider.addEventListener('change', saveState);
        playerJumpSlider.addEventListener('change', saveState);

        backgroundColorPicker.addEventListener('input', (e) => {
            // ... (listener backgroundColorPicker tidak berubah) ...
            if(editorMode) {
                clearBackgroundMedia();
                levelSettings.backgroundColor = e.target.value;
                canvas.style.backgroundColor = e.target.value;
            }
        });
        backgroundColorPicker.addEventListener('change', (e) => { if (editorMode) saveState(); });

        setBackgroundImageBtn.addEventListener('click', () => backgroundImageInput.click());
        setBackgroundVideoBtn.addEventListener('click', () => backgroundVideoInput.click());

        clearBackgroundBtn.addEventListener('click', () => {
            // ... (listener clearBackgroundBtn tidak berubah) ...
            clearBackgroundMedia();
            saveState();
        });
        
        function clearBackgroundMedia() {
            // ... (fungsi clearBackgroundMedia tidak berubah) ...
            levelSettings.backgroundImageSrc = null;
            levelSettings.backgroundVideoSrc = null;
            levelBackgroundImage = null;
            backgroundVideo.src = ''; 
        }

        backgroundImageInput.addEventListener('change', (e) => {
            // ... (listener backgroundImageInput tidak berubah) ...
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    clearBackgroundMedia();
                    levelSettings.backgroundImageSrc = event.target.result;
                    loadBackgroundMedia();
                    saveState();
                }
                reader.readAsDataURL(file);
            }
        });
        
        backgroundVideoInput.addEventListener('change', (e) => {
            // ... (listener backgroundVideoInput tidak berubah) ...
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    clearBackgroundMedia();
                    levelSettings.backgroundVideoSrc = event.target.result;
                    loadBackgroundMedia();
                    saveState();
                }
                reader.readAsDataURL(file);
            }
        });

        function loadBackgroundMedia() {
            // ... (fungsi loadBackgroundMedia tidak berubah) ...
            canvas.style.backgroundColor = levelSettings.backgroundColor || '#000000';
            levelBackgroundImage = null;
            backgroundVideo.src = '';
            
            if (levelSettings.backgroundVideoSrc) {
                backgroundVideo.src = levelSettings.backgroundVideoSrc;
                backgroundVideo.play();
            } else if (levelSettings.backgroundImageSrc) {
                levelBackgroundImage = new Image();
                levelBackgroundImage.src = levelSettings.backgroundImageSrc;
            }
        }

        hookEnabledCheckbox.addEventListener('change', (e) => {
            // ... (listener hookEnabledCheckbox tidak berubah) ...
            if (editorMode) {
                levelSettings.hookEnabled = e.target.checked;
                saveState();
            }
        });
        
        // ... (listener tombol event timeline tidak berubah) ...
        addTextEventBtn.addEventListener('click', () => {
            currentTimelineEventType = 'text';
            addTextEventBtn.classList.add('active');
            addColorEventBtn.classList.remove('active');
        });
        addColorEventBtn.addEventListener('click', () => {
            currentTimelineEventType = 'background_color';
            addColorEventBtn.classList.add('active');
            addTextEventBtn.classList.remove('active');
        });

        // ... (listener mouse timeline tidak berubah) ...
        timelineCanvas.addEventListener('mousedown', (e) => {
            if (!editorMode) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const time = (clickX / rect.width) * TIMELINE_MAX_SECONDS;

            let clickedOnEvent = false;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    selectedTimelineEventId = event.id;
                    selectedObjectId = null;
                    if (clickX < eventStartX + 5) {
                        timelineDragState = { isDragging: false, isResizing: 'left', targetId: event.id };
                    } else if (clickX > eventEndX - 5) {
                        timelineDragState = { isDragging: false, isResizing: 'right', targetId: event.id };
                    } else {
                        timelineDragState = { isDragging: true, isResizing: null, targetId: event.id, offset: time - event.startTime };
                    }
                    clickedOnEvent = true;
                    break;
                }
            }

            if (!clickedOnEvent) {
                selectedTimelineEventId = Date.now();
                const newEvent = {
                    id: selectedTimelineEventId,
                    type: currentTimelineEventType,
                    startTime: time,
                    duration: 10,
                };
                if(currentTimelineEventType === 'text') {
                    Object.assign(newEvent, { text: 'New Event', fontSize: 24, color: '#FFFFFF' });
                } else { // background_color
                    Object.assign(newEvent, { color: '#0000FF' });
                }
                levelSettings.timelineEvents.push(newEvent);
                timelineDragState = { isDragging: true, isResizing: null, targetId: selectedTimelineEventId, offset: 0 };
            }
            updateSettingsPanel();
            updateTimelineSettingsPanel();
            drawTimeline();
        });
        timelineCanvas.addEventListener('mousemove', (e) => {
            if (!editorMode || (!timelineDragState.isDragging && !timelineDragState.isResizing)) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const time = (mouseX / rect.width) * TIMELINE_MAX_SECONDS;
            const targetEvent = levelSettings.timelineEvents.find(ev => ev.id === timelineDragState.targetId);
            if (!targetEvent) return;

            if (timelineDragState.isDragging) {
                targetEvent.startTime = Math.max(0, time - timelineDragState.offset);
            } else if (timelineDragState.isResizing === 'left') {
                const oldEndTime = targetEvent.startTime + targetEvent.duration;
                targetEvent.startTime = Math.max(0, time);
                targetEvent.duration = oldEndTime - targetEvent.startTime;
            } else if (timelineDragState.isResizing === 'right') {
                targetEvent.duration = Math.max(1, time - targetEvent.startTime);
            }
            drawTimeline();
        });
        timelineCanvas.addEventListener('mouseup', () => {
            if (timelineDragState.isDragging || timelineDragState.isResizing) {
                saveState();
            }
            timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        });
        timelineCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!editorMode) return;
            
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;

            let clickedOnEvent = null;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    clickedOnEvent = event;
                    break;
                }
            }

            if(clickedOnEvent) {
                levelSettings.timelineEvents = levelSettings.timelineEvents.filter(ev => ev.id !== clickedOnEvent.id);
                if (selectedTimelineEventId === clickedOnEvent.id) {
                    selectedTimelineEventId = null;
                    updateTimelineSettingsPanel();
                }
                drawTimeline();
                saveState();
            }
        });
        
        // ... (listener input event timeline tidak berubah) ...
        eventTextContentInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.text = e.target.value; saveState(); }
        });
        eventTextSizeInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.fontSize = parseInt(e.target.value, 10); saveState(); }
        });
        eventTextColorInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.color = e.target.value; saveState(); }
        });
         eventBgColorInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.color = e.target.value; saveState(); }
        });
        
        closeSettingsPanelBtn.addEventListener('click', () => {
            // ... (listener closeSettingsPanelBtn tidak berubah) ...
            selectedObjectId = null;
            updateSettingsPanel();
        });

        closeTimelinePanelBtn.addEventListener('click', () => {
            // ... (listener closeTimelinePanelBtn tidak berubah) ...
            selectedTimelineEventId = null;
            updateTimelineSettingsPanel();
            drawTimeline(); 
        });

        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        canvas.addEventListener('mousemove', updateMousePos);
        canvas.addEventListener('mousedown', mouseDownHandler);
        canvas.addEventListener('mouseup', mouseUpHandler);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // ... (listener saveButton tidak berubah) ...
        saveButton.addEventListener('click', () => {
            const data = JSON.stringify({ objects: levelObjects, settings: levelSettings }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Load Button (di editor)
        // ... (listener loadButton tidak berubah) ...
        loadButton.addEventListener('click', () => {
            loadMode = 'editor'; // Set mode untuk load ke editor
            isPlayOnlyMode = false;
            importFileInput.click();
        });

        // Listener Input File (untuk SEMUA mode load)
        // ... (listener importFileInput tidak berubah) ...
        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.objects && data.settings) {
                        // Tentukan mode berdasarkan 'loadMode'
                        const startInPlayOnly = (loadMode === 'play'); 
                        loadLevelData(data, startInPlayOnly); // Muat data
                        alert('Level loaded successfully!');
                    } else {
                        alert('Invalid level file format.');
                    }
                } catch (error) {
                    alert('Error loading or parsing level file.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
            importFileInput.value = '';
        });
        
        // LISTENER TOMBOL HAPUS BARU
        clearAllButton.addEventListener('click', () => {
            // Hanya berfungsi di mode editor
            if (!editorMode) return;
            
            // Ini adalah tindakan berbahaya. Karena kita tidak bisa menggunakan confirm(),
            // kita akan langsung melanjutkannya. Undo (Z) bisa mengembalikannya.
            
            // Hapus semua objek kecuali platform dasar
            levelObjects = [
                { id: Date.now(), type: 'platform', x: 0, y: worldHeight - 20, width: worldWidth, height: 20, color: '#999999', isSolid: true }
            ];
            
            // Reset pengaturan timeline
            levelSettings.timelineEvents = [];
            drawTimeline();

            // Reset posisi player & checkpoint
            checkpointPosition = null;
            const startPos = playerStart; // Reset ke default
            Object.assign(player, { x: startPos.x, y: startPos.y });

            // Deselect objek
            selectedObjectId = null;
            updateSettingsPanel();
            
            // Simpan state "kosong" ini ke history
            saveState(); 
            console.log("Level cleared!");
        });

        function loadLevelData(data, playOnly) {
            // ... (fungsi loadLevelData tidak berubah) ...
            levelObjects = data.objects;
            levelSettings = data.settings;
            
            // ... (sisa fungsi loadLevelData tidak berubah) ...
            if (levelSettings.hookEnabled === undefined) { levelSettings.hookEnabled = false; }
            if (levelSettings.backgroundVideoSrc === undefined) { levelSettings.backgroundVideoSrc = null; }
            if (levelSettings.backgroundImageSrc === undefined) { levelSettings.backgroundImageSrc = null; }
            if (levelSettings.platformSpeed === undefined) { levelSettings.platformSpeed = 2; }


            hookEnabledCheckbox.checked = levelSettings.hookEnabled;

            activeAudio = {};
            levelObjects.forEach(obj => {
                if (obj.type === 'music' && obj.musicSrc) {
                    const audio = new Audio(obj.musicSrc);
                    audio.loop = true;
                    activeAudio[obj.id] = audio;
                }
            });

            laserSpeedSlider.value = levelSettings.laserSpeed;
            platformSpeedSlider.value = levelSettings.platformSpeed;
            playerSpeedSlider.value = levelSettings.playerMaxSpeed;
            playerAccelSlider.value = levelSettings.playerAcceleration;
            playerJumpSlider.value = levelSettings.playerJumpPower;

            backgroundColorPicker.value = levelSettings.backgroundColor || '#000000';
            loadBackgroundMedia();
            
            applySettingsToPlayer();
            saveState(); 
            drawTimeline();
            startGame(playOnly); // Mulai game dengan mode yang benar
        }
        
        // ... (fungsi fireHook, detachHook, updateHook tidak berubah) ...
        function fireHook() {
            hookState.isFiring = true;
            hookState.x = player.x + player.width / 2;
            hookState.y = player.y + player.height / 2;
            const dx = mouseX - hookState.x;
            const dy = mouseY - hookState.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            hookState.velocityX = (dx / dist) * hookState.speed;
            hookState.velocityY = (dy / dist) * hookState.speed;
            hookState.startX = hookState.x;
            hookState.startY = hookState.y;
        }
        function detachHook() {
            hookState.isHooked = false;
            hookState.isFiring = false;
            hookState.attachedObjectId = null;
            const speed = Math.sqrt(player.velocityX * player.velocityX + player.velocityY * player.velocityY);
            if (speed > 10) {
                player.velocityX *= 1.1;
                player.velocityY *= 1.1;
            }
            player.jumpsMade = 0;
        }
        function updateHook() {
            if (!hookState.isFiring) return;
            hookState.x += hookState.velocityX;
            hookState.y += hookState.velocityY;
            for (const obj of levelObjects) {
                // DIPERBARUI: Hook sekarang bisa menempel di semua platform solid
                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') &&
                    hookState.x >= obj.x && hookState.x <= obj.x + obj.width &&
                    hookState.y >= obj.y && hookState.y <= obj.y + obj.height) {
                    
                    hookState.isFiring = false;
                    hookState.isHooked = true;
                    hookState.attachedObjectId = obj.id;
                    const dx = (player.x + player.width / 2) - hookState.x;
                    const dy = (player.y + player.height / 2) - hookState.y;
                    hookState.ropeLength = Math.sqrt(dx*dx + dy*dy);
                    return; 
                }
            }
            const dxRange = hookState.x - hookState.startX;
            const dyRange = hookState.y - hookState.startY;
            const distTraveled = Math.sqrt(dxRange*dxRange + dyRange*dyRange);
            if (distTraveled >= hookState.maxLength) {
                hookState.isFiring = false;
            }
        }

        function drawHook() {
            // ... (fungsi drawHook tidak berubah) ...
            if (!hookState.isFiring && !hookState.isHooked) return;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y + player.height / 2);
            ctx.lineTo(hookState.x, hookState.y);
            ctx.stroke();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(hookState.x, hookState.y, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawLevelObjects() {
            // ... (fungsi drawLevelObjects tidak berubah) ...
            levelObjects.forEach(obj => {
                if (!editorMode && obj.isSolid === false && obj.type !== 'text_block' && obj.type !== 'grappler' && obj.type !== 'corndog' && obj.type !== 'flag') { return; }
                let color = obj.color || '#999';
                ctx.fillStyle = color;
                ctx.globalAlpha = (editorMode && obj.isSolid === false) ? 0.5 : 1.0;

                switch(obj.type) {
                    case 'platform': case 'spawn': case 'laser_source': case 'end':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'music':
                        // ... (draw music tidak berubah) ...
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(obj.x + obj.width * 0.4, obj.y + obj.height * 0.7, obj.width * 0.15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillRect(obj.x + obj.width * 0.55, obj.y + obj.height * 0.2, obj.width * 0.1, obj.height * 0.5);
                        ctx.fillRect(obj.x + obj.width * 0.4, obj.y + obj.height * 0.2, obj.width * 0.25, obj.height*0.1);
                        break;
                    case 'grappler':
                        // ... (draw grappler tidak berubah) ...
                        if (editorMode || (obj.visible && !obj.collected)) {
                            ctx.globalAlpha = (editorMode && !obj.visible) ? 0.4 : 1.0;
                            ctx.fillStyle = obj.color;
                            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                            ctx.strokeStyle = 'white';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(obj.x + obj.width * 0.5, obj.y + obj.height * 0.5, obj.width * 0.2, Math.PI, Math.PI * 1.8);
                            ctx.moveTo(obj.x + obj.width * 0.5, obj.y + obj.height * 0.3);
                            ctx.lineTo(obj.x + obj.width * 0.5, obj.y + obj.height * 0.2);
                            ctx.lineTo(obj.x + obj.width * 0.3, obj.y + obj.height * 0.4);
                            ctx.stroke();
                        }
                        break;
                    // Penambahan Corndog & Flag BARU
                    case 'corndog':
                        if (editorMode || !obj.collected) {
                            ctx.globalAlpha = (editorMode && obj.collected) ? 0.4 : 1.0;
                            if (corndogImage.complete && corndogImage.naturalHeight !== 0) {
                                ctx.drawImage(corndogImage, obj.x, obj.y, obj.width, obj.height);
                            } else {
                                ctx.fillRect(obj.x, obj.y, obj.width, obj.height); // Fallback
                            }
                        }
                        break;
                    case 'flag':
                        if (corndogImage.complete && corndogImage.naturalHeight !== 0) {
                            ctx.drawImage(corndogImage, obj.x, obj.y, obj.width, obj.height);
                        } else {
                            ctx.fillStyle = '#FFA500'; // Fallback
                            ctx.fillRect(obj.x, obj.y, obj.width, obj.height); 
                        }
                        break;
                    case 'text_block':
                        // ... (draw text_block tidak berubah) ...
                        if(editorMode || (!obj.showOnTrigger || obj.visible)) {
                            if (editorMode) {
                                ctx.fillStyle = obj.color || '#333333';
                                ctx.globalAlpha = 0.5;
                                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                                ctx.globalAlpha = 1.0;
                            }
                            ctx.save();
                            ctx.font = `${obj.fontSize || 32}px ${obj.fontFamily || "'Courier New'"}`;
                            ctx.fillStyle = obj.textColor || '#FFFFFF';
                            if (obj.glowSize > 0) {
                                ctx.shadowColor = obj.glowColor || '#000000';
                                ctx.shadowBlur = obj.glowSize || 0;
                            }
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(obj.content || '', obj.x + obj.width/2, obj.y + obj.height/2);
                            ctx.restore(); 
                        }
                        break;
                    case 'spike':
                        // ... (draw spike tidak berubah) ...
                        ctx.beginPath();
                        let o = obj.orientation || 'up';
                        if (o === 'up') { ctx.moveTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); } 
                        else if (o === 'down') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width / 2, obj.y + obj.height); } 
                        else if (o === 'left') { ctx.moveTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); ctx.lineTo(obj.x, obj.y + obj.height / 2); } 
                        else if (o === 'right') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2); }
                        ctx.closePath(); ctx.fill(); break;
                    case 'button':
                        ctx.fillStyle = obj.activated ? '#00ff00' : color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'decay':
                        ctx.globalAlpha = obj.phased ? 0.3 : (obj.isSolid === false ? 0.2 : 1.0); ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'delay':
                         ctx.globalAlpha = (1.0 - (obj.delayTimer / DELAY_BLOCK_FADE_TIME)) * ((editorMode && obj.isSolid === false) ? 0.5 : 1.0);
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                }
                ctx.globalAlpha = 1.0; 
            });
        }
        
        // FUNGSI GAMBAR PARTIKEL BARU
        function drawShatterParticles() {
            shatterParticles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.width, p.height);
            });
        }
        
        function drawChasingLaser() {
            // ... (fungsi drawChasingLaser tidak berubah) ...
            levelObjects.forEach(laserSource => {
                if (laserSource.type === 'laser_source' && laserSource.isActive) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 4;
                    let o = laserSource.orientation || 'left';
                    if (o === 'left') { ctx.fillRect(laserSource.position, 0, 10, worldHeight); ctx.strokeRect(laserSource.position, 0, 10, worldHeight); } 
                    else if (o === 'right') { ctx.fillRect(laserSource.position - 10, 0, 10, worldHeight); ctx.strokeRect(laserSource.position - 10, 0, 10, worldHeight); } 
                    else if (o === 'up') { ctx.fillRect(0, laserSource.position, worldWidth, 10); ctx.strokeRect(0, laserSource.position, worldWidth, 10); } 
                    else if (o === 'down') { ctx.fillRect(0, laserSource.position - 10, worldWidth, 10); ctx.strokeRect(0, laserSource.position - 10, worldWidth, 10); }
                }
            });
        }

        function drawSelectionArrows(obj) {
            // ... (fungsi drawSelectionArrows tidak berubah) ...
            ctx.fillStyle = 'yellow';
            const size = 10;
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y - size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height + size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y + obj.height); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x - size, obj.y + obj.height / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width + size, obj.y + obj.height / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
        }

        function drawEditorElements() {
            // ... (fungsi drawEditorElements tidak berubah) ...
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1;
            for (let x = 0; x < worldWidth; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke(); }
            for (let y = 0; y < worldHeight; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke(); }
            if (isDragging) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
                const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
                let rectW = Math.abs(endX - dragStartX), rectH = Math.abs(endY - dragStartY);
                if (isSelectionRotated) [rectW, rectH] = [rectH, rectW];
                ctx.fillRect(Math.min(dragStartX, endX), Math.min(dragStartY, endY), rectW, rectH);
            }
            if (pathCreationState.isCreating) {
                const sourceObject = levelObjects.find(obj => obj.id === pathCreationState.sourceObjectId);
                if (sourceObject) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(sourceObject.x + sourceObject.width / 2, sourceObject.y + sourceObject.height / 2);
                    ctx.lineTo(mouseX, mouseY);
                    ctx.stroke();
                }
            }
            levelObjects.forEach(obj => {
                if (obj.movePath) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(obj.movePath.start.x + obj.width / 2, obj.movePath.start.y + obj.height / 2);
                    ctx.lineTo(obj.movePath.end.x + obj.width / 2, obj.movePath.end.y + obj.height / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    drawSelectionArrows(selectedObject);
                    if (selectedObject.type === 'laser_source') {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                        const o = selectedObject.orientation || 'left';
                        if (o === 'left') ctx.fillRect(selectedObject.x, 0, worldWidth, worldHeight);
                        if (o === 'right') ctx.fillRect(0, 0, selectedObject.x, worldHeight);
                        if (o === 'up') ctx.fillRect(0, selectedObject.y, worldWidth, worldHeight);
                        if (o === 'down') ctx.fillRect(0, 0, worldWidth, selectedObject.y);
                    }
                }
            }
            levelObjects.forEach(obj => {
                if (obj.type === 'button' && obj.linkedTo) {
                    obj.linkedTo.forEach(targetId => {
                        const targetObj = levelObjects.find(t => t.id === targetId);
                        if(targetObj) {
                            ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)'; ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height / 2);
                            ctx.lineTo(targetObj.x + targetObj.width / 2, targetObj.y + targetObj.height / 2);
                            ctx.stroke();
                        }
                    });
                }
            });
        }
        
        function drawPlayer(p_object, isLocalPlayer) {
            // DIPERBARUI: Jangan gambar player jika sedang dalam animasi kematian
            if (isLocalPlayer && playerState === 'dying') return;
            
            // Logika Skin Kustom BARU
            // ... (sisa logika drawPlayer tidak berubah) ...
            if (isLocalPlayer && playerSkinDataUrl && playerSkinImage.complete && playerSkinImage.naturalHeight !== 0) {
                ctx.imageSmoothingEnabled = false; // Jaga piksel tetap tajam
                ctx.drawImage(playerSkinImage, p_object.x, p_object.y, p_object.width, p_object.height);
                ctx.imageSmoothingEnabled = true;
            } else {
                // Gambar default
                ctx.fillStyle = p_object.color || '#FFFFFF';
                ctx.fillRect(p_object.x, p_object.y, p_object.width, p_object.height);

                // Outline hitam
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.strokeRect(p_object.x, p_object.y, p_object.width, p_object.height);
                
                // Tanda plus oranye hanya untuk pemain lokal
                if (isLocalPlayer) {
                    ctx.fillStyle = '#FFA500';
                    const crossWidth = p_object.width * 0.2;
                    const crossLength = p_object.width * 0.6;
                    ctx.fillRect(p_object.x + (p_object.width - crossLength) / 2, p_object.y + (p_object.height - crossWidth) / 2, crossLength, crossWidth);
                    ctx.fillRect(p_object.x + (p_object.width - crossWidth) / 2, p_object.y + (p_object.height - crossLength) / 2, crossWidth, crossLength);
                }
            }

            // Username
            if (p_object.username) {
                ctx.fillStyle = 'white';
                ctx.font = '14px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText(p_object.username, p_object.x + p_object.width / 2, p_object.y - 10);
            }
            
            // Indikator hook
            if (isLocalPlayer && p_object.hasHook && !hookState.isFiring && !hookState.isHooked) {
                const iconX = p_object.x + p_object.width + 5;
                const iconY = p_object.y + p_object.height / 2;
                const iconSize = 15;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.arc(iconX, iconY, iconSize * 0.4, Math.PI * 0.9, Math.PI * 1.9);
                ctx.moveTo(iconX, iconY - iconSize * 0.4);
                ctx.lineTo(iconX, iconY - iconSize * 0.8);
                ctx.lineTo(iconX - iconSize * 0.3, iconY - iconSize * 0.5);
                ctx.stroke();
            }
        }

        function drawWinMessage() {
            // ... (fungsi drawWinMessage tidak berubah) ...
            ctx.fillStyle = 'white';
            ctx.font = '60px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('YOU WIN!', camera.x + canvas.width / 2, camera.y + canvas.height/2);
        }
        
        function drawActiveTextEvents() {
            // ... (fungsi drawActiveTextEvents tidak berubah) ...
            const activeTextEvents = levelSettings.timelineEvents.filter(event => 
                event.type === 'text' && gameTime >= event.startTime && gameTime < event.startTime + event.duration);

            activeTextEvents.forEach(event => {
                ctx.fillStyle = event.color || '#FFFFFF';
                ctx.font = `${event.fontSize || 24}px 'Courier New'`;
                ctx.textAlign = 'center';
                ctx.fillText(event.text, camera.x + canvas.width / 2, camera.y + canvas.height / 4);
            });
        }
        
        // ... (fungsi lerpColor & updateBackgroundColor tidak berubah) ...
        function lerpColor(a, b, amount) { 
            const ar = a >> 16, ag = a >> 8 & 0xff, ab = a & 0xff,
                  br = b >> 16, bg = b >> 8 & 0xff, bb = b & 0xff,
                  rr = ar + amount * (br - ar),
                  rg = ag + amount * (bg - ag),
                  rb = ab + amount * (bb - ab);
            return (rr << 16 | rg << 8 | rb | 0).toString(16).padStart(6, '0');
        };
        function updateBackgroundColor() {
            if (levelSettings.backgroundImageSrc || levelSettings.backgroundVideoSrc) return; 

            const colorEvents = levelSettings.timelineEvents.filter(e => e.type === 'background_color').sort((a,b) => a.startTime - b.startTime);
            let currentEvent = null;
            let nextEvent = null;

            for (let i = 0; i < colorEvents.length; i++) {
                if (gameTime >= colorEvents[i].startTime) {
                    currentEvent = colorEvents[i];
                    if (i + 1 < colorEvents.length) {
                        nextEvent = colorEvents[i+1];
                    }
                }
            }
            
            if (currentEvent) {
                if (nextEvent) {
                    const progress = (gameTime - currentEvent.startTime) / (nextEvent.startTime - currentEvent.startTime);
                    const color1 = parseInt(currentEvent.color.substring(1), 16);
                    const color2 = parseInt(nextEvent.color.substring(1), 16);
                    canvas.style.backgroundColor = `#${lerpColor(color1, color2, Math.min(1, progress))}`;
                } else {
                    canvas.style.backgroundColor = currentEvent.color;
                }
            } else {
                 canvas.style.backgroundColor = levelSettings.backgroundColor;
            }
        }

        function drawTimeline() {
            // ... (fungsi drawTimeline tidak berubah) ...
            timelineCtx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            timelineCtx.fillStyle = '#ddd';
            timelineCtx.fillRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            
            levelSettings.timelineEvents.forEach(event => {
                const x = (event.startTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                const width = (event.duration / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = event.type === 'text' ? '#ADD8E6' : '#FFB6C1';
                timelineCtx.fillRect(x, 0, width, timelineCanvas.height);
                if (event.id === selectedTimelineEventId) {
                    timelineCtx.strokeStyle = 'yellow';
                    timelineCtx.lineWidth = 3;
                    timelineCtx.strokeRect(x, 0, width, timelineCanvas.height);
                }
            });

            if (!editorMode) {
                const playheadX = (gameTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = 'red';
                timelineCtx.fillRect(playheadX - 1, 0, 2, timelineCanvas.height);
            }
        }
        
        // FUNGSI ANIMASI KEMATIAN BARU
        function updateDeathAnimation() {
            deathTimer++;
            
            // Update partikel
            for (let i = shatterParticles.length - 1; i >= 0; i--) {
                const p = shatterParticles[i];
                p.x += p.velocityX;
                p.y += p.velocityY;
                p.velocityY += gravity; // Partikel jatuh dengan gravitasi
                
                // Hapus partikel jika sudah terlalu lama (opsional)
                if (p.y > camera.y + canvas.height + 100) {
                     shatterParticles.splice(i, 1);
                }
            }
            
            // Transisi ke state 'dead' setelah animasi selesai
            if (deathTimer >= DEATH_ANIM_DURATION) {
                playerState = 'dead';
                deathScreenOverlay.style.display = 'flex'; // Tampilkan menu kematian
            }
        }
        
        // FUNGSI GAMBAR OVERLAY KEMATIAN BARU
        function drawDeathAnimationOverlay() {
            // Gambar fade hitam di atas UI (screen space)
            let opacity = Math.min(0.9, deathTimer / DEATH_ANIM_DURATION); // Max 0.9 agar tidak hitam total
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        let lastUpdateTime = 0;
        const updateInterval = 1000 / 15; 
        
        let onGround = false; // Variabel global untuk onGround

        function update() {
            const now = performance.now();
            
            // --- LOOP UTAMA DIPERBARUI DENGAN STATE ---
            
            if (!editorMode) {
                
                // State 1: Sedang Hidup
                if (playerState === 'alive') {
                    if(gameWon) {
                        // Game dimenangkan
                    } else {
                        gameTime += 1 / 60;
                        gameTimerDisplay.textContent = gameTime.toFixed(2);
                        updateBackgroundColor();
                        
                        if (levelSettings.hookEnabled && player.hasHook) {
                            updateHook();
                        }
                        
                        const isPlayerHooked = hookState.isHooked;
                        const hookedPlatformId = hookState.attachedObjectId;

                        // --- LOGIKA LASER ---
                        levelObjects.forEach(laserSource => {
                            // ... (logika laser tidak berubah) ...
                            if(laserSource.type === 'laser_source' && laserSource.isActive) {
                                let o = laserSource.orientation || 'left';
                                if(o === 'left' || o === 'up') laserSource.position += levelSettings.laserSpeed;
                                else laserSource.position -= levelSettings.laserSpeed;

                                let laserHitbox;
                                if(o === 'left') laserHitbox = {x: laserSource.position, y: 0, width: 10, height: worldHeight};
                                if(o === 'right') laserHitbox = {x: laserSource.position - 10, y: 0, width: 10, height: worldHeight};
                                if(o === 'up') laserHitbox = {x: 0, y: laserSource.position, width: worldWidth, height: 10};
                                if(o === 'down') laserHitbox = {x: 0, y: laserSource.position - 10, width: worldWidth, height: 10};
                                // PERUBAHAN: Panggil triggerPlayerDeath
                                if(laserHitbox && checkRectCollision(player, laserHitbox)) triggerPlayerDeath();
                            }
                        });


                        // --- LOGIKA PLATFORM BERGERAK ---
                        // ... (logika platform bergerak tidak berubah) ...
                        levelObjects.forEach(obj => {
                            if (obj.movePath) {
                                if (isPlayerHooked && obj.id !== hookedPlatformId) {
                                    return; 
                                }

                                const target = obj.moveDirection === 1 ? obj.movePath.end : obj.movePath.start;
                                const dx = target.x - obj.x, dy = target.y - obj.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const speed = obj.moveSpeed || levelSettings.platformSpeed;
                                
                                let moveX = 0, moveY = 0;
                                if (dist >= speed) {
                                    moveX = (dx / dist) * speed;
                                    moveY = (dy / dist) * speed;
                                }

                                if (isPlayerHooked && obj.id === hookedPlatformId) {
                                    player.x += moveX; player.y += moveY;
                                    hookState.x += moveX; hookState.y += moveY;
                                } else if (!isPlayerHooked) {
                                    const preMovePlayerHitbox = {x: player.x, y: player.y, width: player.width, height: player.height + 1};
                                    if (checkRectCollision(preMovePlayerHitbox, obj)) {
                                        player.x += moveX; player.y += moveY;
                                    }
                                }

                                if (dist < speed) {
                                    obj.x = target.x; obj.y = target.y; 
                                    obj.moveDirection *= -1;
                                } else {
                                    obj.x += moveX; obj.y += moveY;
                                }
                            }
                        });
                        
                        if (isPlayerHooked) {
                            // --- FISIKA SWINGING ---
                            // ... (logika swing tidak berubah) ...
                            if (keys.d) player.velocityX += 0.2;
                            if (keys.a) player.velocityX -= 0.2;
                            
                            if(keys.w) hookState.ropeLength -= 1.5;
                            if(keys.s) hookState.ropeLength += 1.5;
                            hookState.ropeLength = Math.max(20, Math.min(hookState.maxLength, hookState.ropeLength));

                            player.velocityY += gravity;
                            player.x += player.velocityX;

                            levelObjects.forEach(obj => {
                                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                    if (player.velocityX > 0 && player.x - player.velocityX + player.width <= obj.x + 1) {
                                        player.x = obj.x - player.width;
                                        player.velocityX = 0;
                                    } else if (player.velocityX < 0 && player.x - player.velocityX >= obj.x + obj.width - 1) {
                                        player.x = obj.x + obj.width;
                                        player.velocityX = 0;
                                    }
                                }
                            });

                            player.y += player.velocityY;

                            levelObjects.forEach(obj => {
                                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                    if (player.velocityY > 0 && player.y - player.velocityY + player.height <= obj.y + 1) {
                                        player.y = obj.y - player.height;
                                        player.velocityY = 0;
                                    } else if (player.velocityY < 0 && player.y - player.velocityY >= obj.y + obj.height - 1) {
                                        player.y = obj.y + obj.height;
                                        player.velocityY = 0;
                                    }
                                }
                            });

                            player.velocityX *= 0.995; 

                            const playerCenterX = player.x + player.width / 2;
                            const playerCenterY = player.y + player.height / 2;
                            const dx = playerCenterX - hookState.x;
                            const dy = playerCenterY - hookState.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist > hookState.ropeLength) {
                                const diff = dist - hookState.ropeLength;
                                const percent = diff / dist;
                                const offsetX = dx * percent;
                                const offsetY = dy * percent;

                                player.x -= offsetX;
                                player.y -= offsetY;
                                
                                const dot = player.velocityX * (dx / dist) + player.velocityY * (dy / dist);
                                player.velocityX -= (dx / dist) * dot;
                                player.velocityY -= (dy / dist) * dot;
                            }

                        } else {
                            // --- FISIKA PLATFORMING NORMAL ---
                            onGround = false; // Reset di setiap frame
                            
                            // ... (logika delay block tidak berubah) ...
                            const touchingHitbox = { x: player.x - 1, y: player.y - 1, width: player.width + 2, height: player.height + 2 };
                            levelObjects.forEach(obj => {
                                if (obj.type === 'delay') {
                                    if (!obj.isFading && obj.isSolid && checkRectCollision(touchingHitbox, obj)) {
                                        obj.isFading = true;
                                    }
                                    if (obj.isFading) {
                                        obj.delayTimer = Math.min(DELAY_BLOCK_FADE_TIME, obj.delayTimer + 1);
                                    }
                                    obj.phased = obj.delayTimer >= DELAY_BLOCK_FADE_TIME;
                                }
                            });

                            if (jumpBufferCounter > 0) jumpBufferCounter--;
                            
                            let wallTouchDirection = 0;
                            
                            if (player.isWallHolding) {
                                // ... (logika wall holding tidak berubah) ...
                                let isStillNextToWall = false;
                                const checkRect = { x: player.x + (player.wallDirection === 1 ? player.width : -1), y: player.y, width: 1, height: player.height };
                                for (const obj of levelObjects) {
                                    if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased)  || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(checkRect, obj)) {
                                        isStillNextToWall = true; break;
                                    }
                                }
                                if (!isStillNextToWall) { 
                                    player.isWallHolding = false;
                                } else {
                                    player.velocityX = 0;
                                    if (keys.w) { 
                                        player.velocityY -= player.wallClimbAcceleration;
                                        if (player.velocityY < -player.maxWallClimbSpeed) player.velocityY = -player.maxWallClimbSpeed;
                                    } else if (keys.s) {
                                        player.velocityY += player.wallClimbAcceleration;
                                        if (player.velocityY > player.maxWallClimbSpeed) player.velocityY = player.maxWallClimbSpeed;
                                    } else {
                                        if (player.velocityY > 0) {
                                            player.velocityY -= player.wallClimbFriction;
                                            if (player.velocityY < 0) player.velocityY = 0;
                                        } else if (player.velocityY < 0) {
                                            player.velocityY += player.wallClimbFriction;
                                            if (player.velocityY > 0) player.velocityY = 0;
                                        }
                                    }
                                    const isPressingAway = (keys.a && player.wallDirection === 1) || (keys.d && player.wallDirection === -1);
                                    if (isPressingAway) {
                                        player.isWallHolding = false; 
                                        player.jumpsMade = 1;
                                    }
                                }
                            } 
                            
                            if (!player.isWallHolding) {
                                // ... (logika sprint tidak berubah) ...
                                player.isSprinting = keys.shift && !player.isCrouching && !player.isDashing;
                                let currentMaxSpeed = player.maxSpeed * (player.isSprinting ? player.sprintMultiplier : 1);
                                if (!player.isDashing) {
                                    if (keys.d) { player.velocityX = Math.min(currentMaxSpeed, player.velocityX + player.acceleration); } 
                                    else if (keys.a) { player.velocityX = Math.max(-currentMaxSpeed, player.velocityX - player.acceleration); } 
                                    else {
                                        if (player.velocityX > 0) { player.velocityX = Math.max(0, player.velocityX - player.friction); } 
                                        else if (player.velocityX < 0) { player.velocityX = Math.min(0, player.velocityX + player.friction); }
                                    }
                                }
                                
                                // Logika Coyote Time DITERAPKAN
                                if (player.coyoteTimeCounter <= 0) { 
                                    player.velocityY += gravity; 
                                }
                            }
                            
                            // ... (logika crouch & dash tidak berubah) ...
                            const touchingGround = levelObjects.some(obj => obj.isSolid && (obj.type === 'platform' || (obj.type === 'delay' && !obj.phased)) && checkRectCollision({x:player.x, y:player.y+1, width: player.width, height:player.height}, obj));
                            if (keys.s && !player.isWallHolding && touchingGround) { 
                                if (player.isSprinting && !player.isDashing) {
                                    player.isDashing = true;
                                    player.dashSpeed = player.maxSpeed * player.sprintMultiplier * 1.5;
                                    player.velocityX = player.dashSpeed * Math.sign(player.velocityX || 1);
                                }
                                if (!player.isCrouching) {
                                    player.y += player.originalHeight / 2;
                                    player.height = player.originalHeight / 2;
                                    player.isCrouching = true;
                                }
                            } else if (player.isCrouching && canStandUp()) { 
                                player.y -= player.originalHeight / 2;
                                player.height = player.originalHeight;
                                player.isCrouching = false;
                                player.isDashing = false;
                            }
                            if (player.isDashing) { 
                                player.dashSpeed -= player.dashFriction;
                                if (player.dashSpeed <= 0) player.isDashing = false;
                                player.velocityX = player.dashSpeed * Math.sign(player.velocityX);
                            }

                            // --- Horizontal Collision ---
                            // ... (logika tumbukan horizontal tidak berubah) ...
                            player.x += player.velocityX;
                            levelObjects.forEach(obj => {
                                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                    if (player.velocityX > 0) { player.x = obj.x - player.width; wallTouchDirection = 1; } 
                                    else if (player.velocityX < 0) { player.x = obj.x + obj.width; wallTouchDirection = -1; }
                                    player.velocityX = 0;
                                }
                            });

                            // --- Vertical Collision ---
                            // ... (logika tumbukan vertikal tidak berubah) ...
                            player.y += player.velocityY;
                            levelObjects.forEach(obj => {
                                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                    if (player.isWallHolding && player.velocityY < 0 && (player.y + player.height <= obj.y + Math.abs(player.wallClimbAcceleration * (keys.w ? -1 : 1)))) {
                                        player.y = obj.y - player.height; onGround = true; player.isWallHolding = false;
                                    } else if (player.velocityY >= 0 && player.y - player.velocityY + player.height <= obj.y + 1) { // Mendarat
                                        player.y = obj.y - player.height; player.velocityY = 0; onGround = true; 
                                        player.isWallHolding = false; 
                                        // (Reset jumps/coyote ditangani di bawah)
                                    } else if (player.velocityY < 0 && player.y - player.velocityY >= obj.y + obj.height - 1) { // Bentur kepala
                                        player.y = obj.y + obj.height; player.velocityY = 0;
                                    }
                                }
                            });
                            
                            // --- Logika Status Setelah Tumbukan ---
                            // ... (logika status tidak berubah) ...
                            if (onGround) {
                                player.jumpsMade = 0;
                                // player.coyoteTimeCounter = COYOTE_TIME_FRAMES; // --- MOD --- Diganti
                                // --- NEW: Logika Coyote Time Dinamis ---
                                if (player.lastAction === 'walljump') {
                                    player.coyoteTimeCounter = COYOTE_TIME_FRAMES_WALLJUMP; // 1.5 detik
                                } else {
                                    player.coyoteTimeCounter = COYOTE_TIME_FRAMES_NORMAL; // 1 detik
                                }
                                player.lastAction = 'landed'; // Reset aksi saat mendarat
                                // --- END NEW ---

                                if (jumpBufferCounter > 0) { // Lompat buffer
                                    player.velocityY = -player.jumpPower; 
                                    player.jumpsMade = 1; 
                                    jumpBufferCounter = 0;
                                    player.coyoteTimeCounter = 0;
                                }
                            } else {
                                if (player.coyoteTimeCounter > 0) {
                                    player.coyoteTimeCounter--;
                                }
                                // Cek wall jump buffer
                                if (jumpBufferCounter > 0 && player.isWallHolding) {
                                    player.isWallHolding = false;
                                    player.velocityY = -player.jumpPower;
                                    player.velocityX = -player.wallDirection * player.jumpPower * 0.75; 
                                    player.jumpsMade = 1;
                                    jumpBufferCounter = 0;
                                }
                            }


                            // --- Interaksi Objek ---
                            levelObjects.forEach(obj => {
                                // Spike sudah ditangani oleh checkPlayerSpikeCollision
                                if (obj.isSolid && obj.type === 'spike') {
                                    // checkPlayerSpikeCollision dipanggil di atas
                                } 
                                else if (checkRectCollision(player, obj)) {
                                    if (obj.type === 'grappler' && obj.visible && !obj.collected) {
                                        player.hasHook = true;
                                        obj.collected = true;
                                    }
                                    // Koleksi Corndog BARU
                                    if (obj.type === 'corndog' && !obj.collected) {
                                        obj.collected = true;
                                        corndogCount++;
                                        updateCorndogDisplay();
                                    }
                                    if (obj.type === 'button' && !obj.activated) {
                                        // ... (logika tombol tidak berubah) ...
                                        obj.activated = true;
                                        if (obj.linkedTo) {
                                            obj.linkedTo.forEach(targetId => {
                                                const targetObj = levelObjects.find(t => t.id === targetId);
                                                if(targetObj) {
                                                    if(targetObj.type === 'text_block' && targetObj.showOnTrigger) { targetObj.visible = true; }
                                                    if(targetObj.type === 'grappler') { targetObj.visible = true; }
                                                    if (targetObj.type === 'decay') {
                                                        targetObj.phased = true;
                                                        setTimeout(() => { targetObj.phased = false; obj.activated = false; }, 10000);
                                                    }
                                                    if (targetObj.type === 'end') {
                                                        gameWon = true;
                                                    }
                                                    if (targetObj.type === 'music' && activeAudio[targetObj.id]) {
                                                        Object.values(activeAudio).forEach(audio => audio.pause());
                                                        activeAudio[targetObj.id].currentTime = 0;
                                                        const playPromise = activeAudio[targetObj.id].play();
                                                        if (playPromise !== undefined) {
                                                            playPromise.catch(error => console.error("Audio play failed:", error));
                                                        }
                                                    }
                                                    if (targetObj.type === 'laser_source') {
                                                        levelObjects.forEach(l => { if(l.type === 'laser_source') { l.isActive = false; clearTimeout(l.activationTimeout); } });
                                                        if (obj.laserLinkDirection) {
                                                            targetObj.orientation = obj.laserLinkDirection;
                                                        }
                                                        let o = targetObj.orientation || 'left';
                                                        if (o === 'left' || o === 'right') targetObj.position = targetObj.x;
                                                        else targetObj.position = targetObj.y;
                                                        targetObj.activationTimeout = setTimeout(() => { targetObj.isActive = true; }, 500);
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                            
                            // Menanam Checkpoint Corndog BARU
                            if (keys.f && corndogCount > 0 && onGround) {
                                corndogCount--;
                                updateCorndogDisplay();
                                checkpointPosition = { x: player.x, y: player.y };
                                // Hapus bendera lama
                                levelObjects = levelObjects.filter(obj => obj.type !== 'flag');
                                // Tambah bendera baru
                                levelObjects.push({ 
                                    id: Date.now(), 
                                    type: 'flag', 
                                    x: player.x, 
                                    y: player.y, 
                                    width: 40, // Sesuaikan ukuran
                                    height: 40, // Sesuaikan ukuran
                                    isSolid: false 
                                });
                                keys.f = false; // Hindari penanaman berulang
                            }
                            
                            // BARU: Logika Wall Grab DIPERBARUI untuk me-reset lompatan
                            if (!player.isWallHolding && !onGround && wallTouchDirection !== 0) {
                                player.isWallHolding = true;
                                player.wallDirection = wallTouchDirection;
                                player.jumpsMade = 0; // BARU: Wall grab me-reset lompatan
                                player.coyoteTimeCounter = 0;
                                player.velocityY = 0;
                            }
                        }
                         
                        if (player.x < 0) player.x = 0;
                        if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
                        
                        if (player.y > worldHeight) {
                            triggerPlayerDeath(); // PERUBAHAN: Panggil triggerPlayerDeath
                        }
                    }
                }
                // State 2: Sedang Mati (Animasi)
                else if (playerState === 'dying') {
                    updateDeathAnimation();
                }
                // State 3: Mati (Menu)
                else if (playerState === 'dead') {
                    // Logika ditangani oleh event listener tombol
                }
                
            } else { // editorMode true
                // ... (logika editor tidak berubah) ...
                if (keys.d) camera.x += editorCameraSpeed; if (keys.a) camera.x -= editorCameraSpeed;
                if (keys.s) camera.y += editorCameraSpeed; if (keys.w) camera.y -= editorCameraSpeed;
            }

            // --- KAMERA DAN GAMBAR ---
            let targetCameraX = editorMode ? camera.x : player.x - canvas.width / 2 + player.width / 2;
            let targetCameraY = editorMode ? camera.y : player.y - canvas.height / 2 + player.height / 2;

            if (!editorMode) {
                camera.x += (targetCameraX - camera.x) * 0.1;
                camera.y += (targetCameraY - camera.y) * 0.1;
            } else {
                 camera.x = targetCameraX;
                 camera.y = targetCameraY;
            }
           
            if (camera.x < 0) camera.x = 0; if (camera.x + canvas.width > worldWidth) camera.x = worldWidth - canvas.width;
            if (camera.y < 0) camera.y = 0; if (camera.y + canvas.height > worldHeight) camera.y = worldHeight - canvas.height;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ... (logika gambar background tidak berubah) ...
            if (levelSettings.backgroundVideoSrc && !backgroundVideo.paused && backgroundVideo.readyState >= 3) {
                const ar = backgroundVideo.videoWidth / backgroundVideo.videoHeight;
                const cr = canvas.width / canvas.height;
                let dw = canvas.width, dh = canvas.height;
                let ox = 0, oy = 0;
                if (ar > cr) { dw = canvas.height * ar; ox = (canvas.width - dw) / 2; } 
                else { dh = canvas.width / ar; oy = (canvas.height - dh) / 2; }
                ctx.drawImage(backgroundVideo, ox, oy, dw, dh);
            } else if (levelBackgroundImage && levelBackgroundImage.complete) {
                const ar = levelBackgroundImage.width / levelBackgroundImage.height;
                const cr = canvas.width / canvas.height;
                let dw = canvas.width, dh = canvas.height;
                let ox = 0, oy = 0;
                if (ar > cr) { dw = canvas.height * ar; ox = (canvas.width - dw) / 2; } 
                else { dh = canvas.width / ar; oy = (canvas.height - dh) / 2; }
                ctx.drawImage(levelBackgroundImage, ox, oy, dw, dh);
            }
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            drawLevelObjects();
            
            if (editorMode) {
                drawEditorElements();
            } else {
                drawChasingLaser();
                drawShatterParticles(); // BARU: Gambar partikel di dunia game
            }
            
            if (levelSettings.hookEnabled) {
                drawHook();
            }

            if(!gameWon) {
                // drawPlayer diperbarui untuk tidak menggambar saat 'dying'
                drawPlayer(player, true); 
            }
            
            ctx.restore();

            // --- UI DI ATAS SEGALANYA (SCREEN SPACE) ---
            
            if (!editorMode) {
                drawActiveTextEvents();
            }

            if (gameWon) {
                drawWinMessage();
            }
            
            // BARU: Gambar overlay fade-to-black saat animasi kematian
            if (playerState === 'dying') {
                drawDeathAnimationOverlay();
            }

            drawTimeline();
            requestAnimationFrame(update);
        }

        // Fungsi Tampilan Corndog BARU
        function updateCorndogDisplay() {
            // ... (fungsi updateCorndogDisplay tidak berubah) ...
            corndogCountSpan.textContent = `x ${corndogCount}`;
        }

        function startGame(playOnly = false) { 
            isPlayOnlyMode = playOnly;
            editorMode = !playOnly;
            
            mainMenu.style.display = 'none';
            document.getElementById('editor-wrapper').style.display = 'flex';
            
            const controlsContainer = document.getElementById('controls-container');
            if (playOnly) {
                controlsContainer.style.display = 'none';
                gameTimerDisplay.style.display = 'block';
                corndogDisplay.style.display = 'flex'; // Tampilkan corndog
                controlsDisplay.style.display = 'block';
            } else { // Mode Editor
                controlsContainer.style.display = 'flex';
                controlsText.textContent = "EDITOR MODE [W,A,S,D to Pan | Q to Toggle]";
                gameTimerDisplay.style.display = 'none';
                corndogDisplay.style.display = 'none'; // Sembunyikan corndog
                controlsDisplay.style.display = 'none';
                // Reset panel editor
                inventoryPanel.style.display = 'none';
                gameSettingsPanel.style.display = 'none';
                inventoryToggleBtn.classList.remove('active');
                settingsToggleBtn.classList.remove('active');
            }
            
            // Reset corndog hanya saat level dimulai, bukan saat mati
            levelObjects.forEach(obj => {
                if(obj.type === 'corndog') {
                    obj.collected = false;
                }
            });
            corndogCount = 0;
            updateCorndogDisplay();
            
            respawnPlayer(); // Panggil respawnPlayer
        }
        
        // ... (level tutorial tidak berubah) ...
        const tutorialLevel = {
            settings: {
                laserSpeed: 1.5, playerMaxSpeed: 5, playerAcceleration: 0.4, playerJumpPower: 13,
                platformSpeed: 2,
                backgroundColor: '#1a2a3a',
                hookEnabled: true,
                timelineEvents: [
                    { id: 1, type: 'text', startTime: 1, duration: 5, text: "Use A/D to move, SPACE to jump.", fontSize: 24, color: '#FFFFFF' },
                    { id: 2, type: 'text', startTime: 7, duration: 5, text: "Aim with the mouse and press E to grapple.", fontSize: 24, color: '#FFFFFF' },
                    { id: 3, type: 'text', startTime: 13, duration: 5, text: "Use W/S while hooked to reel in or out.", fontSize: 24, color: '#FFFFFF' },
                    { id: 4, type: 'text', startTime: 19, duration: 5, text: "Swing fast and press E to fly!", fontSize: 24, color: '#FFFFFF' },
                ],
                backgroundImageSrc: null,
                backgroundVideoSrc: null,
            },
            objects: [
                { id: 10, type: 'platform', x: 0, y: worldHeight - 40, width: 400, height: 40, color: '#cccccc', isSolid: true },
                { id: 11, type: 'spawn', x: 40, y: worldHeight - 80, width: 20, height: 20, color: '#00e676', isSolid: true },
                { id: 12, type: 'platform', x: 550, y: worldHeight - 250, width: 250, height: 20, color: '#cccccc', isSolid: true },
                { id: 15, type: 'end', x: 750, y: worldHeight - 290, width: 20, height: 20, color: '#8e24aa', isSolid: true }
            ]
        };

        // --- Event Listeners Inisialisasi ---
        
        playBtn.addEventListener('click', () => {
            // ... (listener playBtn tidak berubah) ...
            mainMenuButtons.style.display = 'none';
            playSubMenu.style.display = 'flex';
        });

        backToMainBtn.addEventListener('click', () => {
            // ... (listener backToMainBtn tidak berubah) ...
            mainMenuButtons.style.display = 'flex';
            playSubMenu.style.display = 'none';
        });

        tutorialBtn.addEventListener('click', () => {
            // ... (listener tutorialBtn tidak berubah) ...
            loadLevelData(tutorialLevel, true); // Selalu mode main
        });
        
        // Tombol Create & Play Solo BARU
        createLevelBtn.addEventListener('click', () => {
            // ... (listener createLevelBtn tidak berubah) ...
            loadMode = 'editor';
            startGame(false); // Mulai dalam mode editor
        });
        
        playSoloBtn.addEventListener('click', () => {
            // ... (listener playSoloBtn tidak berubah) ...
            loadMode = 'play'; // Set mode untuk load ke play
            importFileInput.click(); // Minta pengguna memilih file JSON
        });
        
        // Tombol Menu Kontrol BARU
        // ... (listener tombol kontrol tidak berubah) ...
        controlsBtn.addEventListener('click', () => {
            mainMenu.style.display = 'none';
            controlsScreen.style.display = 'flex';
        });
        backToMainFromControlsBtn.addEventListener('click', () => {
            controlsScreen.style.display = 'none';
            mainMenu.style.display = 'flex';
        });

        // Tombol Menu Skin BARU
        // ... (listener tombol skin tidak berubah) ...
        customizeSkinBtn.addEventListener('click', () => {
            mainMenu.style.display = 'none';
            skinCustomizer.style.display = 'flex';
            drawSkinCanvas(); // Gambar skin saat ini
        });
        backToMainFromSkinBtn.addEventListener('click', () => {
            skinCustomizer.style.display = 'none';
            mainMenu.style.display = 'flex';
        });
        
        // Listener Input Username BARU
        // ... (listener username tidak berubah) ...
        usernameInput.addEventListener('change', (e) => {
            const newUsername = e.target.value.trim();
            if (newUsername) {
                player.username = newUsername;
                usernameInput.value = newUsername; // Set value in case of trim
                
                // Juga simpan ke localStorage
                try {
                    localStorage.setItem('playerUsername', newUsername);
                } catch (err) {
                    console.error("Failed to save username", err);
                }
            } else {
                // Jangan izinkan username kosong, kembalikan
                usernameInput.value = player.username;
            }
        });
        
        // Tombol Toggle Editor BARU
        // ... (listener tombol editor tidak berubah) ...
        inventoryToggleBtn.addEventListener('click', () => {
            const show = inventoryPanel.style.display === 'none';
            inventoryPanel.style.display = show ? 'flex' : 'none';
            inventoryToggleBtn.classList.toggle('active', show);
        });
        settingsToggleBtn.addEventListener('click', () => {
            const show = gameSettingsPanel.style.display === 'none';
            gameSettingsPanel.style.display = show ? 'flex' : 'none';
            settingsToggleBtn.classList.toggle('active', show);
        });

        // --- Logika Kustomisasi Kulit BARU ---
        // ... (logika kustomisasi kulit tidak berubah) ...
        
        function drawSkinCanvas() {
            skinCtx.fillStyle = '#777'; // Latar belakang grid
            skinCtx.fillRect(0, 0, 10, 10);
            if (playerSkinDataUrl) {
                skinCtx.imageSmoothingEnabled = false;
                skinCtx.drawImage(playerSkinImage, 0, 0, 10, 10);
                skinCtx.imageSmoothingEnabled = true;
            }
        }
        
        function getSkinCanvasMousePos(e) {
            const rect = skinCanvas.getBoundingClientRect();
            const scaleX = skinCanvas.width / rect.width;
            const scaleY = skinCanvas.height / rect.height;
            return {
                x: Math.floor((e.clientX - rect.left) * scaleX),
                y: Math.floor((e.clientY - rect.top) * scaleY)
            };
        }

        function drawOnSkin(e) {
            if (!isDrawingSkin) return;
            const pos = getSkinCanvasMousePos(e);
            if (pos.x < 0 || pos.x >= 10 || pos.y < 0 || pos.y >= 10) return;

            if (skinEraserCheckbox.checked) {
                skinCtx.clearRect(pos.x, pos.y, 1, 1);
            } else {
                skinCtx.fillStyle = skinColorPicker.value;
                skinCtx.fillRect(pos.x, pos.y, 1, 1);
            }
        }
        
        skinCanvas.addEventListener('mousedown', (e) => {
            isDrawingSkin = true;
            drawOnSkin(e);
        });
        skinCanvas.addEventListener('mousemove', drawOnSkin);
        skinCanvas.addEventListener('mouseup', () => isDrawingSkin = false);
        skinCanvas.addEventListener('mouseleave', () => isDrawingSkin = false);
        
        skinSaveBtn.addEventListener('click', () => {
            playerSkinDataUrl = skinCanvas.toDataURL();
            playerSkinImage.src = playerSkinDataUrl;
            
            // Simpan Skin ke LocalStorage BARU
            try {
                localStorage.setItem('playerCustomSkin', playerSkinDataUrl);
                alert('Skin saved!');
            } catch (e) {
                console.error("Failed to save skin to localStorage", e);
                alert('Skin saved for this session, but could not save permanently.');
            }
        });
        
        skinLoadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    playerSkinDataUrl = event.target.result;
                    playerSkinImage.src = playerSkinDataUrl;
                    playerSkinImage.onload = () => {
                        drawSkinCanvas();
                    }
                }
                reader.readAsDataURL(file);
            }
        });

        // --- Inisialisasi Akhir ---
        
        // LISTENER TOMBOL UI BARU
        backToMenuInGameBtn.addEventListener('click', goToMainMenu);
        deathRestartBtn.addEventListener('click', respawnPlayer);
        deathMenuBtn.addEventListener('click', goToMainMenu);

        controlsDisplay.innerHTML = `
            <ul>
                <li><b>Move:</b> A / D</li>
                <li><b>Jump:</b> Space</li>
                <li><b>Wall Climb:</b> W (on wall)</li>
                <li><b>Sprint:</b> Hold Shift</li>
                <li><b>Dash/Slide:</b> Sprint + S</li>
                <li><b>Grapple:</b> E</li>
                <li><b>Set Flag:</b> F</li>
            </ul>
        `;

        loadBackgroundMedia();
        addTextEventBtn.classList.add('active');

        saveState();
        respawnPlayer(); // Panggil respawnPlayer
        
        // --- LOGIKA PRELOADER & INTRO ---
        // ... (logika preloader tidak berubah) ...
        window.onload = () => {
            const preloader = document.getElementById('preloader');
            const introScreen = document.getElementById('intro-screen');
            const introLine1 = document.getElementById('intro-line-1');
            const introLine2 = document.getElementById('intro-line-2');
            const mainMenu = document.getElementById('main-menu');

            // 1. Tampilkan preloader (sudah diatur)
            
            // 2. Simulasikan loading
            setTimeout(() => {
                preloader.style.display = 'none';
                introScreen.style.display = 'flex';

                // 3. Intro baris 1
                setTimeout(() => {
                    introLine1.style.opacity = '1';
                }, 500); 

                // 4. Intro baris 2
                setTimeout(() => {
                    introLine1.style.opacity = '0';
                    introLine2.style.opacity = '1';
                }, 2500); 

                // 5. Tampilkan menu utama
                setTimeout(() => {
                    introScreen.style.display = 'none';
                    mainMenu.style.display = 'flex';
                }, 4500); 

            }, 1000); // Waktu preloader
            
            // Muat Username & Skin dari LocalStorage BARU
            try {
                const savedUsername = localStorage.getItem('playerUsername'); // <-- MUAT USERNAME
                if (savedUsername) {
                    player.username = savedUsername;
                    usernameInput.value = savedUsername; // Perbarui kolom input
                }
            } catch (e) {
                console.error("Failed to load username from localStorage", e);
            }

            try {
                const savedSkin = localStorage.getItem('playerCustomSkin'); // <-- MUAT SKIN
                if (savedSkin) {
                    playerSkinDataUrl = savedSkin;
                    playerSkinImage.src = savedSkin;
                }
            } catch (e) {
                console.error("Failed to load skin from localStorage", e);
            }
            
            // Inisialisasi Skin Canvas
            drawSkinCanvas();
        };
        
        // Jalankan game loop utama
        update(); 
    </script>
</body>
</html>


