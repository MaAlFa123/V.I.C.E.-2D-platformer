<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative 2D Platformer & Level Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            font-family: 'Courier New', Courier, monospace;
        }
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            gap: 20px;
        }
        #main-menu h1 {
            font-size: 3em;
            color: #333;
        }
        #main-menu p {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 20px;
        }
        .menu-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        #editor-wrapper, #controls-container {
            display: none; /* Hidden by default, shown by JS */
        }
        #editor-wrapper {
            /* display: flex; */
            flex-direction: row;
            align-items: flex-start;
            gap: 20px;
        }
        #game-container {
            position: relative;
        }
        #background-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            display: none !important; /* Make sure it's always hidden */
        }
        #gameCanvas {
            border: 2px solid #555;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: crosshair;
            background-size: cover;
            background-position: center;
        }
        #game-timer-display {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            display: none; /* Hidden by default */
        }
        #controls-display {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            text-align: left;
            display: none; /* Hidden by default */
            text-shadow: 1px 1px 2px black;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #controls-display ul {
            list-style: none;
        }
         #controls-display li {
            margin-bottom: 4px;
        }
         #controls-display b {
            display: inline-block;
            width: 110px;
            font-weight: bold;
        }
        #controls-container {
            margin-top: 15px;
            /* display: flex; */
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 800px;
        }
        #controls {
            font-size: 1.2em;
            color: #333;
            background-color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            padding: 10px 15px;
            font-size: 1em;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border: 2px solid #555;
            border-radius: 5px;
            background-color: #fff;
            transition: background-color 0.2s, color 0.2s;
        }
        button:hover, button.active {
            background-color: #333;
            color: #fff;
        }
        #editor-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 5px;
            justify-content: center;
            max-width: 800px;
        }
        #settings-panel, #timeline-settings-panel {
            width: 200px;
            background: #ffffff;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 8px;
            position: relative;
        }
        #settings-panel h3, #timeline-settings-panel h3 {
            margin: 0 0 10px 0;
            text-align: center;
            font-size: 1.1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        #settings-panel label, #timeline-settings-panel label {
            font-size: 0.9em;
        }
        #settings-panel input, #settings-panel button, #settings-panel select,
        #timeline-settings-panel input, #timeline-settings-panel button, #timeline-settings-panel select {
            width: 100%;
            padding: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-section {
            border-top: 1px solid #eee;
            padding-top: 10px;
            margin-top: 10px;
        }
        #game-settings {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
            color: #333;
            width: 100%;
        }
        .settings-slider-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 50%;
        }
        .background-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            width: 50%;
            justify-content: center;
        }
        .background-controls button {
            padding: 2px 5px;
            font-size: 0.8em;
            flex-basis: 45%;
         }
        #timeline-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        #timeline-header button {
            font-size: 0.8em;
            padding: 2px 5px;
        }
        #timeline-container {
            margin-top: 10px;
            width: 800px;
            text-align: center;
            color: #333;
        }
        #timeline-canvas {
            width: 100%;
            height: 60px;
            background-color: #ddd;
            border: 1px solid #555;
            cursor: pointer;
        }
        .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 20px;
            height: 20px;
            padding: 0;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 50%;
            background: #f0f0f0;
        }
        .close-btn:hover {
            background: #ff4d4d;
            color: white;
            border-color: #ff4d4d;
        }
        #file-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="main-menu">
        <h1>Creative 2D Platformer</h1>
        <p>Create and play your own levels!</p>
        <div id="main-menu-buttons" class="menu-controls">
            <button id="start-editor-btn">Create New Level</button>
            <button id="play-btn">Play</button>
        </div>
        <div id="play-submenu" class="menu-controls" style="display: none;">
            <button id="tutorial-btn">Tutorial</button>
            <button id="fan-level-btn">FAN Level</button>
            <button id="back-to-main-btn">Back</button>
        </div>
    </div>
    <div id="editor-wrapper">
        <div id="game-container">
            <video id="background-video" loop muted playsinline></video>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="game-timer-display">0.00</div>
            <div id="controls-display"></div>
        </div>
        <div id="settings-panel">
            <button class="close-btn" id="close-settings-panel">X</button>
            <div id="object-settings-content">
                <h3>Object Settings</h3>
                <div id="general-settings">
                    <label for="color-picker">Block Color:</label>
                    <input type="color" id="color-picker">
                    <button id="rotate-btn">Rotate</button>
                    <div class="settings-row">
                         <input type="checkbox" id="transparent-checkbox">
                         <label for="transparent-checkbox">Invisible in Play Mode</label>
                    </div>
                </div>
                <div id="text-block-settings" class="settings-section" style="display: none;">
                    <h4>Text Properties</h4>
                    <label for="text-content-input">Text:</label>
                    <input type="text" id="text-content-input">
                    <label for="font-family-select">Font:</label>
                    <select id="font-family-select">
                        <option value="'Courier New', Courier, monospace">Courier New</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Times New Roman', Times, serif">Times New Roman</option>
                    </select>
                    <label for="font-size-input">Font Size:</label>
                    <input type="number" id="font-size-input" min="8" max="200">
                    <label for="text-color-picker">Text Color:</label>
                    <input type="color" id="text-color-picker" value="#FFFFFF">
                    <label for="text-glow-color-picker">Glow Color:</label>
                    <input type="color" id="text-glow-color-picker" value="#000000">
                     <label for="text-glow-size-input">Glow Size:</label>
                    <input type="number" id="text-glow-size-input" min="0" max="50" value="0">
                </div>
                <div id="button-laser-settings" class="settings-section" style="display: none;">
                    <label for="laser-direction-select">Set Laser Direction:</label>
                    <select id="laser-direction-select">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                    </select>
                </div>
                 <div id="music-block-settings" class="settings-section" style="display: none;">
                    <label for="music-block-file">Music File:</label>
                    <input type="file" id="music-block-file" accept="audio/*">
                </div>
            </div>
        </div>
        <div id="timeline-settings-panel">
            <button class="close-btn" id="close-timeline-panel">X</button>
            <div id="event-text-settings">
                <h3>Text Event</h3>
                <label for="event-text-content">Text:</label>
                <input type="text" id="event-text-content">
                <label for="event-text-size">Size:</label>
                <input type="number" id="event-text-size" value="24">
                 <label for="event-text-color">Color:</label>
                <input type="color" id="event-text-color" value="#FFFFFF">
            </div>
             <div id="event-color-settings" style="display: none;">
                <h3>Background Color Event</h3>
                <label for="event-bg-color">Target Color:</label>
                <input type="color" id="event-bg-color" value="#000000">
            </div>
        </div>
    </div>
    <div id="controls-container">
        <div id="controls">Press 'Q' to toggle Editor, 'Z' to Undo</div>
        <div id="editor-tools">
            <button class="tool-btn active" data-type="select">Select</button>
            <button class="tool-btn" data-type="platform">Platform</button>
            <button class="tool-btn" data-type="spike">Spike</button>
            <button class="tool-btn" data-type="button">Button</button>
            <button class="tool-btn" data-type="decay">Decay Block</button>
            <button class="tool-btn" data-type="delay">Delay Block</button>
             <button class="tool-btn" data-type="text_block">Text Block</button>
             <button class="tool-btn" data-type="music">Music</button>
            <button class="tool-btn" data-type="spawn">Spawn</button>
            <button class="tool-btn" data-type="laser_source">Laser</button>
            <button class="tool-btn" data-type="end">End</button>
            <button class="tool-btn" id="link-tool-btn" data-type="linker">Link</button>
        </div>
        <div id="game-settings">
             <div class="settings-slider-row">
                <label for="laser-speed-slider">Laser Speed:</label>
                <input type="range" id="laser-speed-slider" min="0.5" max="10" step="0.1" value="1.5">
            </div>
             <div class="settings-slider-row">
                <label for="platform-speed-slider">Platform Speed:</label>
                <input type="range" id="platform-speed-slider" min="0.5" max="10" step="0.1" value="2">
            </div>
             <div class="settings-slider-row">
                <label for="player-speed-slider">Player Speed:</label>
                <input type="range" id="player-speed-slider" min="1" max="15" step="0.1" value="5">
            </div>
             <div class="settings-slider-row">
                 <label for="player-accel-slider">Player Accel:</label>
                <input type="range" id="player-accel-slider" min="0.1" max="2" step="0.05" value="0.4">
            </div>
             <div class="settings-slider-row">
                <label for="player-jump-slider">Player Jump:</label>
                <input type="range" id="player-jump-slider" min="5" max="25" step="0.5" value="13">
            </div>
             <div class="settings-slider-row">
                <label for="background-color-picker">BG Color:</label>
                <input type="color" id="background-color-picker" value="#000000">
            </div>
            <div class="background-controls">
                <button id="set-background-image-btn">Set BG Image</button>
                <input type="file" id="background-image-input" accept="image/*" style="display: none;">
                <button id="set-background-video-btn">Set BG Video</button>
                <input type="file" id="background-video-input" accept="video/*" style="display: none;">
                <button id="clear-background-btn">Clear Background</button>
            </div>
            <div class="settings-slider-row">
                <label for="hook-enabled-checkbox">Grappling Hook:</label>
                <input type="checkbox" id="hook-enabled-checkbox">
            </div>
        </div>
        <div id="timeline-container">
            <div id="timeline-header">
                <label>Timeline:</label>
                <button id="add-text-event-btn">Add Text Event</button>
                <button id="add-color-event-btn">Add Color Event</button>
            </div>
            <canvas id="timeline-canvas" width="800" height="60"></canvas>
        </div>
        <div id="file-controls">
            <button id="saveButton">Save Level</button>
            <button id="loadButton">Load Level</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const backgroundVideo = document.getElementById('background-video');
        const gameTimerDisplay = document.getElementById('game-timer-display');
        const controlsDisplay = document.getElementById('controls-display');
        const timelineCanvas = document.getElementById('timeline-canvas');
        const timelineCtx = timelineCanvas.getContext('2d');
        const controlsText = document.getElementById('controls');
        const toolButtons = document.querySelectorAll('.tool-btn');
        
        // Settings Panels
        const settingsPanel = document.getElementById('settings-panel');
        const objectSettingsContent = document.getElementById('object-settings-content');
        const colorPicker = document.getElementById('color-picker');
        const rotateBtn = document.getElementById('rotate-btn');
        const transparentCheckbox = document.getElementById('transparent-checkbox');
        
        // Text Block Settings
        const textBlockSettingsDiv = document.getElementById('text-block-settings');
        const textContentInput = document.getElementById('text-content-input');
        const fontSizeInput = document.getElementById('font-size-input');
        const fontFamilySelect = document.getElementById('font-family-select');
        const textColorPicker = document.getElementById('text-color-picker');
        const textGlowColorPicker = document.getElementById('text-glow-color-picker');
        const textGlowSizeInput = document.getElementById('text-glow-size-input');

        // Other Object Settings
        const buttonLaserSettingsDiv = document.getElementById('button-laser-settings');
        const laserDirectionSelect = document.getElementById('laser-direction-select');
        const musicBlockSettingsDiv = document.getElementById('music-block-settings');
        const musicBlockFileInput = document.getElementById('music-block-file');
        
        // Game Settings
        const laserSpeedSlider = document.getElementById('laser-speed-slider');
        const platformSpeedSlider = document.getElementById('platform-speed-slider');
        const playerSpeedSlider = document.getElementById('player-speed-slider');
        const playerAccelSlider = document.getElementById('player-accel-slider');
        const playerJumpSlider = document.getElementById('player-jump-slider');
        const hookEnabledCheckbox = document.getElementById('hook-enabled-checkbox');
        
        // Background Settings
        const backgroundColorPicker = document.getElementById('background-color-picker');
        const setBackgroundImageBtn = document.getElementById('set-background-image-btn');
        const backgroundImageInput = document.getElementById('background-image-input');
        const setBackgroundVideoBtn = document.getElementById('set-background-video-btn');
        const backgroundVideoInput = document.getElementById('background-video-input');
        const clearBackgroundBtn = document.getElementById('clear-background-btn');
        
        // Timeline
        const timelineSettingsPanel = document.getElementById('timeline-settings-panel');
        const eventTextSettingsDiv = document.getElementById('event-text-settings');
        const eventTextContentInput = document.getElementById('event-text-content');
        const eventTextSizeInput = document.getElementById('event-text-size');
        const eventTextColorInput = document.getElementById('event-text-color');
        const eventColorSettingsDiv = document.getElementById('event-color-settings');
        const eventBgColorInput = document.getElementById('event-bg-color');
        const addTextEventBtn = document.getElementById('add-text-event-btn');
        const addColorEventBtn = document.getElementById('add-color-event-btn');
        const closeSettingsPanelBtn = document.getElementById('close-settings-panel');
        const closeTimelinePanelBtn = document.getElementById('close-timeline-panel');
        
        // File I/O
        const saveButton = document.getElementById('saveButton');
        const loadButton = document.getElementById('loadButton');
        const importFileInput = document.getElementById('import-file-input');
        
        // Main Menu
        const mainMenu = document.getElementById('main-menu');
        const mainMenuButtons = document.getElementById('main-menu-buttons');
        const playSubMenu = document.getElementById('play-submenu');
        const startEditorBtn = document.getElementById('start-editor-btn');
        const playBtn = document.getElementById('play-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const fanLevelBtn = document.getElementById('fan-level-btn');
        const backToMainBtn = document.getElementById('back-to-main-btn');
        
        let editorMode = false;
        let isPlayOnlyMode = false;
        const gridSize = 20;
        const editorCameraSpeed = 10;
        const TIMELINE_MAX_SECONDS = 300;

        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let mouseX = 0, mouseY = 0;
        let currentBlockType = 'select';
        let linkingState = { isLinking: false, sourceButtonId: null };
        let pathCreationState = { isCreating: false, sourceObjectId: null };
        let isSelectionRotated = false;
        let selectedObjectId = null;
        let gameWon = false;
        let gameTime = 0;
        
        let activeAudio = {};
        let levelBackgroundImage = null;

        let selectedTimelineEventId = null;
        let currentTimelineEventType = 'text';
        let timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        
        const worldWidth = 4000;
        const worldHeight = 20000;
        const gravity = 0.6;
        const MAX_JUMPS = 2;
        const JUMP_BUFFER_FRAMES = 8; 
        const DELAY_BLOCK_FADE_TIME = 300; 

        let history = [];
        let historyIndex = -1;

        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const savableObjects = JSON.parse(JSON.stringify(levelObjects));
            history.push(JSON.stringify({ objects: savableObjects, settings: levelSettings }));
            historyIndex++;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const previousState = JSON.parse(history[historyIndex]);
                levelObjects = previousState.objects;
                levelSettings = previousState.settings;
                laserSpeedSlider.value = levelSettings.laserSpeed;
                platformSpeedSlider.value = levelSettings.platformSpeed;
                playerSpeedSlider.value = levelSettings.playerMaxSpeed;
                playerAccelSlider.value = levelSettings.playerAcceleration;
                playerJumpSlider.value = levelSettings.playerJumpPower;
                backgroundColorPicker.value = levelSettings.backgroundColor || '#000000';
                hookEnabledCheckbox.checked = levelSettings.hookEnabled || false;
                loadBackgroundMedia();
                applySettingsToPlayer();
                drawTimeline();
            }
        }
        
        const playerStart = { x: 50, y: worldHeight - 60 };
        const player = {
            x: playerStart.x, y: playerStart.y, width: 40, height: 40,
            originalHeight: 40, velocityX: 0, velocityY: 0, jumpPower: 13,
            jumpsMade: 0, color: '#FFFFFF', acceleration: 0.4, friction: 0.3,
            maxSpeed: 5, isWallHolding: false, 
            wallClimbAcceleration: 0.2, maxWallClimbSpeed: 2.5, wallClimbFriction: 0.3,
            coyoteTimeCounter: 0, coyoteTimeDuration: 30,
            wallDirection: 0, isCrouching: false, isDashing: false, 
            dashSpeed: 0, dashFriction: 0.2, isSprinting: false, 
            sprintMultiplier: 1.6,
        };

        let levelObjects = [
            { id: Date.now(), type: 'platform', x: 0, y: worldHeight - 20, width: worldWidth, height: 20, color: '#999999', isSolid: true },
        ];
        
        let levelSettings = {
            laserSpeed: 1.5,
            platformSpeed: 2,
            playerMaxSpeed: 5,
            playerAcceleration: 0.4,
            playerJumpPower: 13,
            timelineEvents: [],
            backgroundColor: '#000000',
            backgroundImageSrc: null,
            backgroundVideoSrc: null,
            hookEnabled: false,
        };
        
        let hookState = {
            isFiring: false,
            isHooked: false,
            x: 0, y: 0,
            velocityX: 0, velocityY: 0,
            startX: 0, startY: 0,
            ropeLength: 0,
            maxLength: 500,
            speed: 30,
            attachedObjectId: null,
        };

        const camera = { x: 0, y: 0 };
        const keys = { w: false, a: false, s: false, d: false, shift: false, space: false };
        let jumpBufferCounter = 0;

        function applySettingsToPlayer() {
            player.maxSpeed = levelSettings.playerMaxSpeed;
            player.acceleration = levelSettings.playerAcceleration;
            player.jumpPower = levelSettings.playerJumpPower;
        }

        function checkRectCollision(objA, objB) {
            return objA.x < objB.x + objB.width && objA.x + objA.width > objB.x && objA.y < objB.y + objB.height && objA.y + objA.height > objB.y;
        }
        
        function sign(p1, p2, p3) { return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y); }

        function isPointInTriangle(pt, v1, v2, v3) {
            const d1 = sign(pt, v1, v2), d2 = sign(pt, v2, v3), d3 = sign(pt, v3, v1);
            const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0), has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0);
            return !(has_neg && has_pos);
        }

        function checkPlayerSpikeCollision(player, spike) {
            if (!checkRectCollision(player, spike)) return false; 
            const playerCorners = [ { x: player.x, y: player.y }, { x: player.x + player.width, y: player.y }, { x: player.x, y: player.y + player.height }, { x: player.x + player.width, y: player.y + player.height }, ];
            let v1, v2, v3;
            const o = spike.orientation || 'up';
            if (o === 'up') { v1 = { x: spike.x, y: spike.y + spike.height }; v2 = { x: spike.x + spike.width / 2, y: spike.y }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height }; } 
            else if (o === 'down') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y }; v3 = { x: spike.x + spike.width / 2, y: spike.y + spike.height }; } 
            else if (o === 'left') { v1 = { x: spike.x + spike.width, y: spike.y }; v2 = { x: spike.x + spike.width, y: spike.y + spike.height }; v3 = { x: spike.x, y: spike.y + spike.height / 2 }; } 
            else if (o === 'right') { v1 = { x: spike.x, y: spike.y }; v2 = { x: spike.x, y: spike.y + spike.height }; v3 = { x: spike.x + spike.width, y: spike.y + spike.height / 2 }; }
            return playerCorners.some(corner => isPointInTriangle(corner, v1, v2, v3));
        }

        function resetPlayer() {
            gameWon = false;
            gameTime = 0;
            applySettingsToPlayer();
            detachHook();
            
            Object.values(activeAudio).forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });

            levelObjects.forEach(obj => { 
                if(obj.movePath) { obj.x = obj.movePath.start.x; obj.y = obj.movePath.start.y; obj.moveDirection = 1; }
                if(obj.type === 'button') obj.activated = false;
                if(obj.type === 'decay') obj.phased = false;
                if(obj.type === 'delay') { obj.phased = false; obj.delayTimer = 0; obj.isFading = false; }
                if(obj.type === 'laser_source') {
                    clearTimeout(obj.activationTimeout);
                    obj.isActive = false;
                }
            });
            let spawnPoint = levelObjects.find(obj => obj.type === 'spawn');
            const startPos = spawnPoint ? {x: spawnPoint.x, y: spawnPoint.y} : playerStart;
            Object.assign(player, { x: startPos.x, y: startPos.y, velocityX: 0, velocityY: 0, jumpsMade: 0, isDashing: false, isWallHolding: false, coyoteTimeCounter: 0, isCrouching: false, height: player.originalHeight });

            // Instantly snap camera to the new player position
            camera.x = player.x - canvas.width / 2 + player.width / 2;
            camera.y = player.y - canvas.height / 2 + player.height / 2;
        }

        function canStandUp() {
            const standHitbox = { x: player.x, y: player.y - player.originalHeight / 2, width: player.width, height: player.originalHeight };
            return !levelObjects.some(obj => obj.isSolid && obj.type === 'platform' && checkRectCollision(standHitbox, obj));
        }
        
        function keyDownHandler(e) {
            const key = e.key.toLowerCase();
            if (key === 'z' && editorMode) {
                undo();
                return;
            }
            if (key === 'q' && !isPlayOnlyMode) {
                editorMode = !editorMode;
                gameTimerDisplay.style.display = editorMode ? 'none' : 'block';
                controlsDisplay.style.display = editorMode ? 'none' : 'block';
                controlsText.textContent = editorMode ? "EDITOR MODE [W,A,S,D to Pan | Q to Toggle]" : "PLAY MODE";
                if (!editorMode) { 
                    selectedObjectId = null; selectedTimelineEventId = null; updateSettingsPanel(); updateTimelineSettingsPanel(); resetPlayer(); 
                } else {
                    Object.values(activeAudio).forEach(audio => audio.pause());
                }
                return;
            }
            if (key === 'r' && editorMode) { isSelectionRotated = !isSelectionRotated; return; }

            // Gameplay Keys
            if (key === 'd') keys.d = true;
            else if (key === 'a') keys.a = true;
            else if (key === 's') keys.s = true;
            else if (key === 'shift') keys.shift = true;
            else if (key === 'w') keys.w = true; // For climbing / hook reeling
            else if (key === ' ') {
                e.preventDefault();
                keys.space = true;
                jumpBufferCounter = JUMP_BUFFER_FRAMES;
                if (!e.repeat && !editorMode) {
                    if (!player.isWallHolding && !hookState.isHooked && player.jumpsMade < MAX_JUMPS) {
                        player.velocityY = -player.jumpPower;
                        player.jumpsMade++;
                        jumpBufferCounter = 0;
                        player.coyoteTimeCounter = 0;
                    }
                }
            } else if (key === 'e' && !editorMode && levelSettings.hookEnabled && !e.repeat) {
                e.preventDefault();
                if (hookState.isHooked) {
                    detachHook();
                } else if (!hookState.isFiring) {
                    fireHook();
                }
            }
        }

        function keyUpHandler(e) {
            const key = e.key.toLowerCase();
            if (key === 'd') keys.d = false;
            else if (key === 'a') keys.a = false;
            else if (key === 's') keys.s = false;
            else if (key === 'w') keys.w = false;
            else if (key === ' ') keys.space = false;
            else if (key === 'shift') keys.shift = false;
        }
        
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left + camera.x;
            mouseY = e.clientY - rect.top + camera.y;
        }

        function updateSettingsPanel() {
            const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
            
            textBlockSettingsDiv.style.display = 'none';
            buttonLaserSettingsDiv.style.display = 'none';
            musicBlockSettingsDiv.style.display = 'none';
            objectSettingsContent.style.display = 'none';
            
            if (editorMode) {
                 if (selectedObject) {
                    settingsPanel.style.display = 'flex';
                    objectSettingsContent.style.display = 'block';
                    colorPicker.value = selectedObject.color || '#999999';
                    transparentCheckbox.checked = selectedObject.isSolid === false;

                    if (selectedObject.type === 'text_block') {
                        textBlockSettingsDiv.style.display = 'block';
                        textContentInput.value = selectedObject.content || '';
                        fontSizeInput.value = selectedObject.fontSize || 32;
                        fontFamilySelect.value = selectedObject.fontFamily || "'Courier New', Courier, monospace";
                        textColorPicker.value = selectedObject.textColor || '#FFFFFF';
                        textGlowColorPicker.value = selectedObject.glowColor || '#000000';
                        textGlowSizeInput.value = selectedObject.glowSize || 0;
                    }
                     if (selectedObject.type === 'music') {
                        musicBlockSettingsDiv.style.display = 'block';
                    }
                    if (selectedObject.type === 'button' && selectedObject.linkedTo && selectedObject.linkedTo.some(id => {
                        const linked = levelObjects.find(o => o.id === id);
                        return linked && linked.type === 'laser_source';
                    })) {
                        buttonLaserSettingsDiv.style.display = 'block';
                        laserDirectionSelect.value = selectedObject.laserLinkDirection || 'left';
                    }
                } else {
                    settingsPanel.style.display = 'none';
                }
            } else {
                settingsPanel.style.display = 'none';
            }
        }
        
        function updateTimelineSettingsPanel() {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            eventTextSettingsDiv.style.display = 'none';
            eventColorSettingsDiv.style.display = 'none';

            if(event && editorMode) {
                timelineSettingsPanel.style.display = 'flex';
                if (event.type === 'text') {
                    eventTextSettingsDiv.style.display = 'block';
                    eventTextContentInput.value = event.text || '';
                    eventTextSizeInput.value = event.fontSize || 24;
                    eventTextColorInput.value = event.color || '#FFFFFF';
                } else if (event.type === 'background_color') {
                    eventColorSettingsDiv.style.display = 'block';
                    eventBgColorInput.value = event.color || '#000000';
                }
            } else {
                timelineSettingsPanel.style.display = 'none';
            }
        }
        
        function mouseDownHandler(e) {
            if (!editorMode) return;
            e.preventDefault();
            updateMousePos(e);

            const clickedObject = levelObjects.find(obj => mouseX >= obj.x && mouseX <= obj.x + obj.width && mouseY >= obj.y && mouseY <= obj.y + obj.height);

            if (linkingState.isLinking) {
                if (!clickedObject) return;
                if (clickedObject.type === 'button' && !linkingState.sourceButtonId) {
                    linkingState.sourceButtonId = clickedObject.id;
                } else if ((['decay', 'end', 'laser_source', 'music'].includes(clickedObject.type)) && linkingState.sourceButtonId) {
                    const sourceButton = levelObjects.find(obj => obj.id === linkingState.sourceButtonId);
                    if (sourceButton) {
                        if (!sourceButton.linkedTo) sourceButton.linkedTo = [];
                        if (!sourceButton.linkedTo.includes(clickedObject.id)) {
                             sourceButton.linkedTo.push(clickedObject.id);
                        }
                    }
                    linkingState.sourceButtonId = null; 
                    saveState();
                }
                return;
            }

            if (e.button === 0) { // Left Click
                if (currentBlockType === 'select') {
                    selectedObjectId = clickedObject ? clickedObject.id : null;
                    selectedTimelineEventId = null;
                    if (clickedObject) {
                        pathCreationState.isCreating = true;
                        pathCreationState.sourceObjectId = clickedObject.id;
                    }
                    updateSettingsPanel();
                    updateTimelineSettingsPanel();
                } else { // Creation mode
                    selectedObjectId = null; updateSettingsPanel();
                    isDragging = true;
                    dragStartX = Math.floor(mouseX / gridSize) * gridSize;
                    dragStartY = Math.floor(mouseY / gridSize) * gridSize;
                }
            } else if (e.button === 2) { 
                if (clickedObject) {
                    if (clickedObject.movePath) { delete clickedObject.movePath; saveState(); } 
                    else {
                        levelObjects = levelObjects.filter(p => p.id !== clickedObject.id);
                        if (selectedObjectId === clickedObject.id) { selectedObjectId = null; updateSettingsPanel(); }
                        saveState();
                    }
                }
            }
        }

        function mouseUpHandler(e) {
            if (!editorMode) return;
            if (pathCreationState.isCreating) { 
                const sourceObject = levelObjects.find(obj => obj.id === pathCreationState.sourceObjectId);
                if (sourceObject) {
                    const dx = mouseX - (sourceObject.x + sourceObject.width / 2);
                    const dy = mouseY - (sourceObject.y + sourceObject.height / 2);
                    if (dx*dx + dy*dy > 100) { // Only create path if dragged far enough
                        sourceObject.movePath = { 
                            start: { x: sourceObject.x, y: sourceObject.y }, 
                            end: { x: mouseX - sourceObject.width / 2, y: mouseY - sourceObject.height / 2 } 
                        };
                        sourceObject.moveSpeed = parseFloat(platformSpeedSlider.value); 
                        sourceObject.moveDirection = 1;
                        saveState();
                    }
                }
                pathCreationState.isCreating = false; 
                pathCreationState.sourceObjectId = null;
                return;
            }

            if (!isDragging || linkingState.isLinking) return;
            isDragging = false;
            const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
            const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
            let width = Math.abs(endX - dragStartX), height = Math.abs(endY - dragStartY);
            if (isSelectionRotated) [width, height] = [height, width];
            const newObject = {
                id: Date.now() + Math.random(), type: currentBlockType,
                x: Math.min(dragStartX, endX), y: Math.min(dragStartY, endY),
                width: width, height: height, color: '#999999', isSolid: true
            };
            if (newObject.width > 0 && newObject.height > 0) {
                 if(['spawn', 'end'].includes(newObject.type)){
                    levelObjects = levelObjects.filter(o => o.type !== newObject.type); 
                    newObject.width = gridSize; newObject.height = gridSize;
                    if(newObject.type === 'spawn') newObject.color = '#00e676';
                    if(newObject.type === 'end') newObject.color = '#8e24aa';
                 }
                 if(newObject.type === 'laser_source') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#ffa500'; newObject.orientation = 'left';
                    newObject.isActive = false; newObject.position = 0;
                 }
                  if(newObject.type === 'music') {
                    newObject.width = gridSize; newObject.height = gridSize;
                    newObject.color = '#3399ff'; newObject.isSolid = false;
                 }
                 if(newObject.type === 'text_block') {
                    newObject.content = "Text";
                    newObject.fontSize = 32;
                    newObject.fontFamily = "'Courier New', Courier, monospace";
                    newObject.textColor = '#FFFFFF';
                    newObject.glowColor = '#000000';
                    newObject.glowSize = 0;
                    newObject.color = '#333333';
                    newObject.isSolid = false; // Usually text blocks are not solid
                 }
                 if(newObject.type === 'button') { newObject.activated = false; newObject.color = '#ff0000'; }
                 if(newObject.type === 'decay') { newObject.phased = false; newObject.color = '#444444'; }
                 if(newObject.type === 'delay') { newObject.phased = false; newObject.delayTimer = 0; newObject.color = '#666666'; newObject.isFading = false; }
                 if(newObject.type === 'spike') { newObject.color = '#ff0000'; newObject.orientation = 'up'; }
                 levelObjects.push(newObject);
                 saveState();
            }
        }

        toolButtons.forEach(button => {
            button.addEventListener('click', () => {
                toolButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentBlockType = button.dataset.type;
                linkingState.isLinking = currentBlockType === 'linker';
                linkingState.sourceButtonId = null;
                isSelectionRotated = false;
            });
        });
        
        colorPicker.addEventListener('input', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.color = e.target.value; saveState(); }
            }
        });

        transparentCheckbox.addEventListener('change', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) { selectedObject.isSolid = !e.target.checked; saveState(); }
            }
        });
        
        // --- TEXT BLOCK SETTINGS LISTENERS ---
        function updateSelectedTextBlock(prop, value) {
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'text_block') {
                    selectedObject[prop] = value;
                    saveState();
                }
            }
        }
        textContentInput.addEventListener('input', (e) => updateSelectedTextBlock('content', e.target.value));
        fontSizeInput.addEventListener('input', (e) => updateSelectedTextBlock('fontSize', parseInt(e.target.value, 10)));
        fontFamilySelect.addEventListener('change', (e) => updateSelectedTextBlock('fontFamily', e.target.value));
        textColorPicker.addEventListener('input', (e) => updateSelectedTextBlock('textColor', e.target.value));
        textGlowColorPicker.addEventListener('input', (e) => updateSelectedTextBlock('glowColor', e.target.value));
        textGlowSizeInput.addEventListener('input', (e) => updateSelectedTextBlock('glowSize', parseInt(e.target.value, 10)));

        laserDirectionSelect.addEventListener('change', (e) => {
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject && selectedObject.type === 'button') {
                    selectedObject.laserLinkDirection = e.target.value;
                    saveState();
                }
            }
        });

        musicBlockFileInput.addEventListener('change', (e) => {
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                const file = e.target.files[0];
                if (selectedObject && selectedObject.type === 'music' && file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const dataUrl = event.target.result;
                        selectedObject.musicSrc = dataUrl;

                        const audio = new Audio(dataUrl);
                        audio.loop = true;
                        activeAudio[selectedObject.id] = audio;
                        saveState();
                    }
                    reader.readAsDataURL(file);
                }
            }
        });
        
        rotateBtn.addEventListener('click', () => {
             if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    if (selectedObject.type === 'spike' || selectedObject.type === 'laser_source') {
                        const orientations = ['up', 'right', 'down', 'left'];
                        const currentIndex = orientations.indexOf(selectedObject.orientation || 'up');
                        selectedObject.orientation = orientations[(currentIndex + 1) % 4];
                    } else {
                        [selectedObject.width, selectedObject.height] = [selectedObject.height, selectedObject.width];
                    }
                    saveState();
                }
            }
        });
        
        laserSpeedSlider.addEventListener('input', (e) => { levelSettings.laserSpeed = parseFloat(e.target.value); });
        platformSpeedSlider.addEventListener('input', (e) => { levelSettings.platformSpeed = parseFloat(e.target.value); });
        playerSpeedSlider.addEventListener('input', (e) => { levelSettings.playerMaxSpeed = parseFloat(e.target.value); applySettingsToPlayer(); });
        playerAccelSlider.addEventListener('input', (e) => { levelSettings.playerAcceleration = parseFloat(e.target.value); applySettingsToPlayer(); });
        playerJumpSlider.addEventListener('input', (e) => { levelSettings.playerJumpPower = parseFloat(e.target.value); applySettingsToPlayer(); });
        
        laserSpeedSlider.addEventListener('change', saveState);
        platformSpeedSlider.addEventListener('change', saveState);
        playerSpeedSlider.addEventListener('change', saveState);
        playerAccelSlider.addEventListener('change', saveState);
        playerJumpSlider.addEventListener('change', saveState);

        backgroundColorPicker.addEventListener('input', (e) => {
            if(editorMode) {
                clearBackgroundMedia();
                levelSettings.backgroundColor = e.target.value;
                canvas.style.backgroundColor = e.target.value;
            }
        });
        backgroundColorPicker.addEventListener('change', (e) => { if (editorMode) saveState(); });

        setBackgroundImageBtn.addEventListener('click', () => backgroundImageInput.click());
        setBackgroundVideoBtn.addEventListener('click', () => backgroundVideoInput.click());

        clearBackgroundBtn.addEventListener('click', () => {
            clearBackgroundMedia();
            saveState();
        });
        
        function clearBackgroundMedia() {
            levelSettings.backgroundImageSrc = null;
            levelSettings.backgroundVideoSrc = null;
            levelBackgroundImage = null;
            backgroundVideo.src = ''; // Just clear the src
        }

        backgroundImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    clearBackgroundMedia();
                    levelSettings.backgroundImageSrc = event.target.result;
                    loadBackgroundMedia();
                    saveState();
                }
                reader.readAsDataURL(file);
            }
        });
        
        backgroundVideoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    clearBackgroundMedia();
                    levelSettings.backgroundVideoSrc = event.target.result;
                    loadBackgroundMedia();
                    saveState();
                }
                reader.readAsDataURL(file);
            }
        });

        function loadBackgroundMedia() {
            // Set canvas background color as a fallback
            canvas.style.backgroundColor = levelSettings.backgroundColor || '#000000';
            
            // Clear old media
            levelBackgroundImage = null;
            backgroundVideo.src = '';
            
            if (levelSettings.backgroundVideoSrc) {
                backgroundVideo.src = levelSettings.backgroundVideoSrc;
                backgroundVideo.play();
            } else if (levelSettings.backgroundImageSrc) {
                levelBackgroundImage = new Image();
                levelBackgroundImage.src = levelSettings.backgroundImageSrc;
            }
        }


        hookEnabledCheckbox.addEventListener('change', (e) => {
            if (editorMode) {
                levelSettings.hookEnabled = e.target.checked;
                saveState();
            }
        });
        
        addTextEventBtn.addEventListener('click', () => {
            currentTimelineEventType = 'text';
            addTextEventBtn.classList.add('active');
            addColorEventBtn.classList.remove('active');
        });
        addColorEventBtn.addEventListener('click', () => {
            currentTimelineEventType = 'background_color';
            addColorEventBtn.classList.add('active');
            addTextEventBtn.classList.remove('active');
        });


        timelineCanvas.addEventListener('mousedown', (e) => {
            if (!editorMode) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const time = (clickX / rect.width) * TIMELINE_MAX_SECONDS;

            let clickedOnEvent = false;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    selectedTimelineEventId = event.id;
                    selectedObjectId = null;
                    if (clickX < eventStartX + 5) {
                        timelineDragState = { isDragging: false, isResizing: 'left', targetId: event.id };
                    } else if (clickX > eventEndX - 5) {
                        timelineDragState = { isDragging: false, isResizing: 'right', targetId: event.id };
                    } else {
                        timelineDragState = { isDragging: true, isResizing: null, targetId: event.id, offset: time - event.startTime };
                    }
                    clickedOnEvent = true;
                    break;
                }
            }

            if (!clickedOnEvent) {
                selectedTimelineEventId = Date.now();
                const newEvent = {
                    id: selectedTimelineEventId,
                    type: currentTimelineEventType,
                    startTime: time,
                    duration: 10,
                };
                if(currentTimelineEventType === 'text') {
                    Object.assign(newEvent, { text: 'New Event', fontSize: 24, color: '#FFFFFF' });
                } else { // background_color
                    Object.assign(newEvent, { color: '#0000FF' });
                }
                levelSettings.timelineEvents.push(newEvent);
                timelineDragState = { isDragging: true, isResizing: null, targetId: selectedTimelineEventId, offset: 0 };
            }
            updateSettingsPanel();
            updateTimelineSettingsPanel();
            drawTimeline();
        });

        timelineCanvas.addEventListener('mousemove', (e) => {
            if (!editorMode || (!timelineDragState.isDragging && !timelineDragState.isResizing)) return;
            const rect = timelineCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const time = (mouseX / rect.width) * TIMELINE_MAX_SECONDS;
            const targetEvent = levelSettings.timelineEvents.find(ev => ev.id === timelineDragState.targetId);
            if (!targetEvent) return;

            if (timelineDragState.isDragging) {
                targetEvent.startTime = Math.max(0, time - timelineDragState.offset);
            } else if (timelineDragState.isResizing === 'left') {
                const oldEndTime = targetEvent.startTime + targetEvent.duration;
                targetEvent.startTime = Math.max(0, time);
                targetEvent.duration = oldEndTime - targetEvent.startTime;
            } else if (timelineDragState.isResizing === 'right') {
                targetEvent.duration = Math.max(1, time - targetEvent.startTime);
            }
            drawTimeline();
        });

        timelineCanvas.addEventListener('mouseup', () => {
            if (timelineDragState.isDragging || timelineDragState.isResizing) {
                saveState();
            }
            timelineDragState = { isDragging: false, isResizing: null, targetId: null, offset: 0 };
        });

        timelineCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!editorMode) return;
            
            const rect = timelineCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;

            let clickedOnEvent = null;
            for (const event of levelSettings.timelineEvents) {
                const eventStartX = (event.startTime / TIMELINE_MAX_SECONDS) * rect.width;
                const eventEndX = ((event.startTime + event.duration) / TIMELINE_MAX_SECONDS) * rect.width;
                if (clickX >= eventStartX && clickX <= eventEndX) {
                    clickedOnEvent = event;
                    break;
                }
            }

            if(clickedOnEvent) {
                levelSettings.timelineEvents = levelSettings.timelineEvents.filter(ev => ev.id !== clickedOnEvent.id);
                if (selectedTimelineEventId === clickedOnEvent.id) {
                    selectedTimelineEventId = null;
                    updateTimelineSettingsPanel();
                }
                drawTimeline();
                saveState();
            }
        });
        
        eventTextContentInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.text = e.target.value; saveState(); }
        });
        eventTextSizeInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.fontSize = parseInt(e.target.value, 10); saveState(); }
        });
        eventTextColorInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.color = e.target.value; saveState(); }
        });
         eventBgColorInput.addEventListener('input', e => {
            const event = levelSettings.timelineEvents.find(ev => ev.id === selectedTimelineEventId);
            if(event) { event.color = e.target.value; saveState(); }
        });
        
        closeSettingsPanelBtn.addEventListener('click', () => {
            selectedObjectId = null;
            updateSettingsPanel();
        });

        closeTimelinePanelBtn.addEventListener('click', () => {
            selectedTimelineEventId = null;
            updateTimelineSettingsPanel();
            drawTimeline(); 
        });


        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);
        canvas.addEventListener('mousemove', updateMousePos);
        canvas.addEventListener('mousedown', mouseDownHandler);
        canvas.addEventListener('mouseup', mouseUpHandler);
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        saveButton.addEventListener('click', () => {
            const data = JSON.stringify({ objects: levelObjects, settings: levelSettings }, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        loadButton.addEventListener('click', () => {
            isPlayOnlyMode = false;
            importFileInput.click();
        });

        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    if (data.objects && data.settings) {
                        loadLevelData(data, isPlayOnlyMode);
                        alert('Level loaded successfully!');
                    } else {
                        alert('Invalid level file format.');
                    }
                } catch (error) {
                    alert('Error loading or parsing level file.');
                    console.error(error);
                }
            };
            reader.readAsText(file);
            importFileInput.value = '';
        });

        function loadLevelData(data, playOnly) {
            levelObjects = data.objects;
            levelSettings = data.settings;
            
            if (levelSettings.hookEnabled === undefined) { levelSettings.hookEnabled = false; }
            if (levelSettings.backgroundVideoSrc === undefined) { levelSettings.backgroundVideoSrc = null; }
            if (levelSettings.backgroundImageSrc === undefined) { levelSettings.backgroundImageSrc = null; }
            if (levelSettings.platformSpeed === undefined) { levelSettings.platformSpeed = 2; }


            hookEnabledCheckbox.checked = levelSettings.hookEnabled;

            activeAudio = {};
            levelObjects.forEach(obj => {
                if (obj.type === 'music' && obj.musicSrc) {
                    const audio = new Audio(obj.musicSrc);
                    audio.loop = true;
                    activeAudio[obj.id] = audio;
                }
            });

            laserSpeedSlider.value = levelSettings.laserSpeed;
            platformSpeedSlider.value = levelSettings.platformSpeed;
            playerSpeedSlider.value = levelSettings.playerMaxSpeed;
            playerAccelSlider.value = levelSettings.playerAcceleration;
            playerJumpSlider.value = levelSettings.playerJumpPower;

            backgroundColorPicker.value = levelSettings.backgroundColor || '#000000';
            loadBackgroundMedia();
            
            applySettingsToPlayer();
            saveState(); 
            drawTimeline();
            startGame(playOnly);
        }
        
        function fireHook() {
            hookState.isFiring = true;
            hookState.x = player.x + player.width / 2;
            hookState.y = player.y + player.height / 2;

            const dx = mouseX - hookState.x;
            const dy = mouseY - hookState.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            hookState.velocityX = (dx / dist) * hookState.speed;
            hookState.velocityY = (dy / dist) * hookState.speed;

            hookState.startX = hookState.x;
            hookState.startY = hookState.y;
        }

        function detachHook() {
            hookState.isHooked = false;
            hookState.isFiring = false;
            hookState.attachedObjectId = null;

            const speed = Math.sqrt(player.velocityX * player.velocityX + player.velocityY * player.velocityY);
            
            if (speed > 10) {
                player.velocityX *= 1.1;
                player.velocityY *= 1.1;
            }
            
            player.jumpsMade = 0;
        }

        function updateHook() {
            if (!hookState.isFiring) return;

            hookState.x += hookState.velocityX;
            hookState.y += hookState.velocityY;

            for (const obj of levelObjects) {
                if (obj.isSolid && (obj.type === 'platform' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased)) &&
                    hookState.x >= obj.x && hookState.x <= obj.x + obj.width &&
                    hookState.y >= obj.y && hookState.y <= obj.y + obj.height) {
                    
                    hookState.isFiring = false;
                    hookState.isHooked = true;
                    hookState.attachedObjectId = obj.id;
                    
                    const dx = (player.x + player.width / 2) - hookState.x;
                    const dy = (player.y + player.height / 2) - hookState.y;
                    hookState.ropeLength = Math.sqrt(dx*dx + dy*dy);
                    return; 
                }
            }

            const dxRange = hookState.x - hookState.startX;
            const dyRange = hookState.y - hookState.startY;
            const distTraveled = Math.sqrt(dxRange*dxRange + dyRange*dyRange);
            if (distTraveled >= hookState.maxLength) {
                hookState.isFiring = false;
            }
        }
        
        function drawHook() {
            if (!hookState.isFiring && !hookState.isHooked) return;

            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y + player.height / 2);
            ctx.lineTo(hookState.x, hookState.y);
            ctx.stroke();

            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(hookState.x, hookState.y, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawLevelObjects() {
            levelObjects.forEach(obj => {
                if (!editorMode && obj.isSolid === false && obj.type !== 'text_block') { return; }
                let color = obj.color || '#999';
                ctx.fillStyle = color;
                ctx.globalAlpha = (editorMode && obj.isSolid === false) ? 0.5 : 1.0;

                switch(obj.type) {
                    case 'platform': case 'spawn': case 'laser_source': case 'end':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'music':
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(obj.x + obj.width * 0.4, obj.y + obj.height * 0.7, obj.width * 0.15, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillRect(obj.x + obj.width * 0.55, obj.y + obj.height * 0.2, obj.width * 0.1, obj.height * 0.5);
                        ctx.fillRect(obj.x + obj.width * 0.4, obj.y + obj.height * 0.2, obj.width * 0.25, obj.height*0.1);
                        break;
                    case 'text_block':
                        // Draw container in editor mode
                        if (editorMode) {
                            ctx.fillStyle = obj.color || '#333333';
                            ctx.globalAlpha = 0.5;
                            ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                            ctx.globalAlpha = 1.0;
                        }
                        // Draw text content
                        ctx.save();
                        ctx.font = `${obj.fontSize || 32}px ${obj.fontFamily || "'Courier New'"}`;
                        ctx.fillStyle = obj.textColor || '#FFFFFF';
                        if (obj.glowSize > 0) {
                            ctx.shadowColor = obj.glowColor || '#000000';
                            ctx.shadowBlur = obj.glowSize || 0;
                        }
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obj.content || '', obj.x + obj.width/2, obj.y + obj.height/2);
                        ctx.restore(); // Resets shadow properties
                        break;
                    case 'spike':
                        ctx.beginPath();
                        let o = obj.orientation || 'up';
                        if (o === 'up') { ctx.moveTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); } 
                        else if (o === 'down') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width / 2, obj.y + obj.height); } 
                        else if (o === 'left') { ctx.moveTo(obj.x + obj.width, obj.y); ctx.lineTo(obj.x + obj.width, obj.y + obj.height); ctx.lineTo(obj.x, obj.y + obj.height / 2); } 
                        else if (o === 'right') { ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x, obj.y + obj.height); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2); }
                        ctx.closePath(); ctx.fill(); break;
                    case 'button':
                        ctx.fillStyle = obj.activated ? '#00ff00' : color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'decay':
                        ctx.globalAlpha = obj.phased ? 0.3 : (obj.isSolid === false ? 0.2 : 1.0); ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                    case 'delay':
                         ctx.globalAlpha = (1.0 - (obj.delayTimer / DELAY_BLOCK_FADE_TIME)) * ((editorMode && obj.isSolid === false) ? 0.5 : 1.0);
                         ctx.fillRect(obj.x, obj.y, obj.width, obj.height); break;
                }
                ctx.globalAlpha = 1.0; 
            });
        }
        
        function drawChasingLaser() {
            levelObjects.forEach(laserSource => {
                if (laserSource.type === 'laser_source' && laserSource.isActive) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 4;
                    let o = laserSource.orientation || 'left';
                    if (o === 'left') { ctx.fillRect(laserSource.position, 0, 10, worldHeight); ctx.strokeRect(laserSource.position, 0, 10, worldHeight); } 
                    else if (o === 'right') { ctx.fillRect(laserSource.position - 10, 0, 10, worldHeight); ctx.strokeRect(laserSource.position - 10, 0, 10, worldHeight); } 
                    else if (o === 'up') { ctx.fillRect(0, laserSource.position, worldWidth, 10); ctx.strokeRect(0, laserSource.position, worldWidth, 10); } 
                    else if (o === 'down') { ctx.fillRect(0, laserSource.position - 10, worldWidth, 10); ctx.strokeRect(0, laserSource.position - 10, worldWidth, 10); }
                }
            });
        }

        function drawSelectionArrows(obj) {
            ctx.fillStyle = 'yellow';
            const size = 10;
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y - size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height + size); ctx.lineTo(obj.x + obj.width / 2 - size / 2, obj.y + obj.height); ctx.lineTo(obj.x + obj.width / 2 + size / 2, obj.y + obj.height); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x - size, obj.y + obj.height / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(obj.x + obj.width + size, obj.y + obj.height / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 - size / 2); ctx.lineTo(obj.x + obj.width, obj.y + obj.height / 2 + size / 2); ctx.closePath(); ctx.fill();
        }

        function drawEditorElements() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)'; ctx.lineWidth = 1;
            for (let x = 0; x < worldWidth; x += gridSize) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, worldHeight); ctx.stroke(); }
            for (let y = 0; y < worldHeight; y += gridSize) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(worldWidth, y); ctx.stroke(); }
            if (isDragging) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                const endX = Math.floor(mouseX / gridSize) * gridSize + gridSize;
                const endY = Math.floor(mouseY / gridSize) * gridSize + gridSize;
                let rectW = Math.abs(endX - dragStartX), rectH = Math.abs(endY - dragStartY);
                if (isSelectionRotated) [rectW, rectH] = [rectH, rectW];
                ctx.fillRect(Math.min(dragStartX, endX), Math.min(dragStartY, endY), rectW, rectH);
            }
            if (pathCreationState.isCreating) {
                const sourceObject = levelObjects.find(obj => obj.id === pathCreationState.sourceObjectId);
                if (sourceObject) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(sourceObject.x + sourceObject.width / 2, sourceObject.y + sourceObject.height / 2);
                    ctx.lineTo(mouseX, mouseY);
                    ctx.stroke();
                }
            }
            levelObjects.forEach(obj => {
                if (obj.movePath) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(obj.movePath.start.x + obj.width / 2, obj.movePath.start.y + obj.height / 2);
                    ctx.lineTo(obj.movePath.end.x + obj.width / 2, obj.movePath.end.y + obj.height / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            if (selectedObjectId) {
                const selectedObject = levelObjects.find(obj => obj.id === selectedObjectId);
                if (selectedObject) {
                    drawSelectionArrows(selectedObject);
                    if (selectedObject.type === 'laser_source') {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                        const o = selectedObject.orientation || 'left';
                        if (o === 'left') ctx.fillRect(selectedObject.x, 0, worldWidth, worldHeight);
                        if (o === 'right') ctx.fillRect(0, 0, selectedObject.x, worldHeight);
                        if (o === 'up') ctx.fillRect(0, selectedObject.y, worldWidth, worldHeight);
                        if (o === 'down') ctx.fillRect(0, 0, worldWidth, selectedObject.y);
                    }
                }
            }
            levelObjects.forEach(obj => {
                if (obj.type === 'button' && obj.linkedTo) {
                    obj.linkedTo.forEach(targetId => {
                        const targetObj = levelObjects.find(t => t.id === targetId);
                        if(targetObj) {
                            ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)'; ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(obj.x + obj.width / 2, obj.y + obj.height / 2);
                            ctx.lineTo(targetObj.x + targetObj.width / 2, targetObj.y + targetObj.height / 2);
                            ctx.stroke();
                        }
                    });
                }
            });
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function drawWinMessage() {
            ctx.fillStyle = 'white';
            ctx.font = '60px "Courier New"';
            ctx.textAlign = 'center';
            ctx.fillText('YOU WIN!', camera.x + canvas.width / 2, camera.y + canvas.height/2);
        }
        
        function drawActiveTextEvents() {
            const activeTextEvents = levelSettings.timelineEvents.filter(event => 
                event.type === 'text' && gameTime >= event.startTime && gameTime < event.startTime + event.duration);

            activeTextEvents.forEach(event => {
                ctx.fillStyle = event.color || '#FFFFFF';
                ctx.font = `${event.fontSize || 24}px 'Courier New'`;
                ctx.textAlign = 'center';
                ctx.fillText(event.text, camera.x + canvas.width / 2, camera.y + canvas.height / 4);
            });
        }
        
        function lerpColor(a, b, amount) { 
            const ar = a >> 16, ag = a >> 8 & 0xff, ab = a & 0xff,
                  br = b >> 16, bg = b >> 8 & 0xff, bb = b & 0xff,
                  rr = ar + amount * (br - ar),
                  rg = ag + amount * (bg - ag),
                  rb = ab + amount * (bb - ab);
            return (rr << 16 | rg << 8 | rb | 0).toString(16).padStart(6, '0');
        };

        function updateBackgroundColor() {
            if (levelSettings.backgroundImageSrc || levelSettings.backgroundVideoSrc) return; // Don't run if media background is set

            const colorEvents = levelSettings.timelineEvents.filter(e => e.type === 'background_color').sort((a,b) => a.startTime - b.startTime);
            let currentEvent = null;
            let nextEvent = null;

            for (let i = 0; i < colorEvents.length; i++) {
                if (gameTime >= colorEvents[i].startTime) {
                    currentEvent = colorEvents[i];
                    if (i + 1 < colorEvents.length) {
                        nextEvent = colorEvents[i+1];
                    }
                }
            }
            
            if (currentEvent) {
                if (nextEvent) {
                    const progress = (gameTime - currentEvent.startTime) / (nextEvent.startTime - currentEvent.startTime);
                    const color1 = parseInt(currentEvent.color.substring(1), 16);
                    const color2 = parseInt(nextEvent.color.substring(1), 16);
                    canvas.style.backgroundColor = `#${lerpColor(color1, color2, Math.min(1, progress))}`;
                } else {
                    canvas.style.backgroundColor = currentEvent.color;
                }
            } else {
                 canvas.style.backgroundColor = levelSettings.backgroundColor;
            }
        }

        function drawTimeline() {
            timelineCtx.clearRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            timelineCtx.fillStyle = '#ddd';
            timelineCtx.fillRect(0, 0, timelineCanvas.width, timelineCanvas.height);
            
            levelSettings.timelineEvents.forEach(event => {
                const x = (event.startTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                const width = (event.duration / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = event.type === 'text' ? '#ADD8E6' : '#FFB6C1';
                timelineCtx.fillRect(x, 0, width, timelineCanvas.height);
                if (event.id === selectedTimelineEventId) {
                    timelineCtx.strokeStyle = 'yellow';
                    timelineCtx.lineWidth = 3;
                    timelineCtx.strokeRect(x, 0, width, timelineCanvas.height);
                }
            });

            if (!editorMode) {
                const playheadX = (gameTime / TIMELINE_MAX_SECONDS) * timelineCanvas.width;
                timelineCtx.fillStyle = 'red';
                timelineCtx.fillRect(playheadX - 1, 0, 2, timelineCanvas.height);
            }
        }

        function update() {
            if (!editorMode) {
                if(gameWon) {
                    // Game is won, no updates
                } else {
                    gameTime += 1 / 60;
                    gameTimerDisplay.textContent = gameTime.toFixed(2);
                    updateBackgroundColor();
                    
                    if (levelSettings.hookEnabled) {
                        updateHook();
                    }

                    const isPlayerHooked = hookState.isHooked;
                    const hookedPlatformId = hookState.attachedObjectId;

                    // --- LASER LOGIC: ALWAYS MOVES ---
                    levelObjects.forEach(laserSource => {
                        if(laserSource.type === 'laser_source' && laserSource.isActive) {
                            let o = laserSource.orientation || 'left';
                            if(o === 'left' || o === 'up') laserSource.position += levelSettings.laserSpeed;
                            else laserSource.position -= levelSettings.laserSpeed;

                            let laserHitbox;
                            if(o === 'left') laserHitbox = {x: laserSource.position, y: 0, width: 10, height: worldHeight};
                            if(o === 'right') laserHitbox = {x: laserSource.position - 10, y: 0, width: 10, height: worldHeight};
                            if(o === 'up') laserHitbox = {x: 0, y: laserSource.position, width: worldWidth, height: 10};
                            if(o === 'down') laserHitbox = {x: 0, y: laserSource.position - 10, width: worldWidth, height: 10};
                            if(laserHitbox && checkRectCollision(player, laserHitbox)) resetPlayer();
                        }
                    });


                    // --- MOVING PLATFORM LOGIC ---
                    levelObjects.forEach(obj => {
                        if (obj.movePath) {
                            if (isPlayerHooked && obj.id !== hookedPlatformId) {
                                return; // This stops other platforms from moving.
                            }

                            const target = obj.moveDirection === 1 ? obj.movePath.end : obj.movePath.start;
                            const dx = target.x - obj.x, dy = target.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const speed = obj.moveSpeed || levelSettings.platformSpeed;
                            
                            let moveX = 0, moveY = 0;
                            if (dist >= speed) {
                                moveX = (dx / dist) * speed;
                                moveY = (dy / dist) * speed;
                            }

                            if (isPlayerHooked && obj.id === hookedPlatformId) {
                                player.x += moveX; player.y += moveY;
                                hookState.x += moveX; hookState.y += moveY;
                            } else if (!isPlayerHooked) {
                                const preMovePlayerHitbox = {x: player.x, y: player.y, width: player.width, height: player.height + 1};
                                if (checkRectCollision(preMovePlayerHitbox, obj)) {
                                    player.x += moveX; player.y += moveY;
                                }
                            }

                            if (dist < speed) {
                                obj.x = target.x; obj.y = target.y; 
                                obj.moveDirection *= -1;
                            } else {
                                obj.x += moveX; obj.y += moveY;
                            }
                        }
                    });
                    
                    if (isPlayerHooked) {
                        // --- SWINGING PHYSICS ---
                        if (keys.d) player.velocityX += 0.2;
                        if (keys.a) player.velocityX -= 0.2;
                        
                        if(keys.w) hookState.ropeLength -= 1.5;
                        if(keys.s) hookState.ropeLength += 1.5;
                        hookState.ropeLength = Math.max(20, Math.min(hookState.maxLength, hookState.ropeLength));

                        player.velocityY += gravity;
                        player.x += player.velocityX;

                        // --- ROBUST: Horizontal Collision detection during swing ---
                        levelObjects.forEach(obj => {
                            if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                if (player.velocityX > 0 && player.x - player.velocityX + player.width <= obj.x + 1) {
                                    player.x = obj.x - player.width;
                                    player.velocityX = 0;
                                } else if (player.velocityX < 0 && player.x - player.velocityX >= obj.x + obj.width - 1) {
                                    player.x = obj.x + obj.width;
                                    player.velocityX = 0;
                                }
                            }
                        });

                        player.y += player.velocityY;

                        // --- ROBUST: Vertical Collision detection during swing ---
                        levelObjects.forEach(obj => {
                            if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                if (player.velocityY > 0 && player.y - player.velocityY + player.height <= obj.y + 1) {
                                    player.y = obj.y - player.height;
                                    player.velocityY = 0;
                                } else if (player.velocityY < 0 && player.y - player.velocityY >= obj.y + obj.height - 1) {
                                    player.y = obj.y + obj.height;
                                    player.velocityY = 0;
                                }
                            }
                        });

                        player.velocityX *= 0.995; // Air friction

                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;
                        const dx = playerCenterX - hookState.x;
                        const dy = playerCenterY - hookState.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > hookState.ropeLength) {
                            const diff = dist - hookState.ropeLength;
                            const percent = diff / dist;
                            const offsetX = dx * percent;
                            const offsetY = dy * percent;

                            player.x -= offsetX;
                            player.y -= offsetY;
                            
                            const dot = player.velocityX * (dx / dist) + player.velocityY * (dy / dist);
                            player.velocityX -= (dx / dist) * dot;
                            player.velocityY -= (dy / dist) * dot;
                        }

                    } else {
                        // --- NORMAL PLATFORMING PHYSICS ---
                        let onGround = false;
                        
                        const touchingHitbox = { x: player.x - 1, y: player.y - 1, width: player.width + 2, height: player.height + 2 };
                        levelObjects.forEach(obj => {
                            if (obj.type === 'delay') {
                                if (!obj.isFading && obj.isSolid && checkRectCollision(touchingHitbox, obj)) {
                                    obj.isFading = true;
                                }
                                if (obj.isFading) {
                                    obj.delayTimer = Math.min(DELAY_BLOCK_FADE_TIME, obj.delayTimer + 1);
                                }
                                obj.phased = obj.delayTimer >= DELAY_BLOCK_FADE_TIME;
                            }
                        });

                        if (jumpBufferCounter > 0) jumpBufferCounter--;
                        
                        let wallTouchDirection = 0;
                        
                        if (player.isWallHolding) {
                            let isStillNextToWall = false;
                            const checkRect = { x: player.x + (player.wallDirection === 1 ? player.width : -1), y: player.y, width: 1, height: player.height };
                            for (const obj of levelObjects) {
                                if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased)  || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(checkRect, obj)) {
                                    isStillNextToWall = true; break;
                                }
                            }
                            if (!isStillNextToWall) { 
                                player.isWallHolding = false;
                            } else {
                                player.velocityX = 0;
                                if (keys.w) { // W FOR CLIMBING
                                    player.velocityY -= player.wallClimbAcceleration;
                                    if (player.velocityY < -player.maxWallClimbSpeed) player.velocityY = -player.maxWallClimbSpeed;
                                } else if (keys.s) {
                                    player.velocityY += player.wallClimbAcceleration;
                                    if (player.velocityY > player.maxWallClimbSpeed) player.velocityY = player.maxWallClimbSpeed;
                                } else {
                                    if (player.velocityY > 0) {
                                        player.velocityY -= player.wallClimbFriction;
                                        if (player.velocityY < 0) player.velocityY = 0;
                                    } else if (player.velocityY < 0) {
                                        player.velocityY += player.wallClimbFriction;
                                        if (player.velocityY > 0) player.velocityY = 0;
                                    }
                                }
                                const isPressingAway = (keys.a && player.wallDirection === 1) || (keys.d && player.wallDirection === -1);
                                if (isPressingAway) {
                                    player.isWallHolding = false; 
                                    player.coyoteTimeCounter = player.coyoteTimeDuration; 
                                    player.jumpsMade = 1;
                                }
                            }
                        } 
                        
                        if (!player.isWallHolding) {
                            player.isSprinting = keys.shift && !player.isCrouching && !player.isDashing;
                            let currentMaxSpeed = player.maxSpeed * (player.isSprinting ? player.sprintMultiplier : 1);
                            if (!player.isDashing) {
                                if (keys.d) { player.velocityX = Math.min(currentMaxSpeed, player.velocityX + player.acceleration); } 
                                else if (keys.a) { player.velocityX = Math.max(-currentMaxSpeed, player.velocityX - player.acceleration); } 
                                else {
                                    if (player.velocityX > 0) { player.velocityX = Math.max(0, player.velocityX - player.friction); } 
                                    else if (player.velocityX < 0) { player.velocityX = Math.min(0, player.velocityX + player.friction); }
                                }
                            }
                            if (player.coyoteTimeCounter > 0) { player.coyoteTimeCounter--; player.velocityY = gravity * 0.5; } 
                            else { player.velocityY += gravity; }
                        }
                        
                        const touchingGround = levelObjects.some(obj => obj.isSolid && (obj.type === 'platform' || (obj.type === 'delay' && !obj.phased)) && checkRectCollision({x:player.x, y:player.y+1, width: player.width, height:player.height}, obj));
                        if (keys.s && !player.isWallHolding && touchingGround) { 
                            if (player.isSprinting && !player.isDashing) {
                                player.isDashing = true;
                                player.dashSpeed = player.maxSpeed * player.sprintMultiplier * 1.5;
                                player.velocityX = player.dashSpeed * Math.sign(player.velocityX || 1);
                            }
                            if (!player.isCrouching) {
                                player.y += player.originalHeight / 2;
                                player.height = player.originalHeight / 2;
                                player.isCrouching = true;
                            }
                        } else if (player.isCrouching && canStandUp()) { 
                            player.y -= player.originalHeight / 2;
                            player.height = player.originalHeight;
                            player.isCrouching = false;
                            player.isDashing = false;
                        }
                        if (player.isDashing) { 
                            player.dashSpeed -= player.dashFriction;
                            if (player.dashSpeed <= 0) player.isDashing = false;
                            player.velocityX = player.dashSpeed * Math.sign(player.velocityX);
                        }

                        player.x += player.velocityX;
                        levelObjects.forEach(obj => {
                            if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                if (player.velocityX > 0) { player.x = obj.x - player.width; wallTouchDirection = 1; } 
                                else if (player.velocityX < 0) { player.x = obj.x + obj.width; wallTouchDirection = -1; }
                                player.velocityX = 0;
                            }
                        });

                        player.y += player.velocityY;
                        
                        onGround = false;
                        levelObjects.forEach(obj => {
                            if (obj.isSolid && (obj.type === 'platform' || obj.type === 'spawn' || (obj.type === 'decay' && !obj.phased) || (obj.type === 'delay' && !obj.phased) || obj.type === 'end') && checkRectCollision(player, obj)) {
                                if (player.isWallHolding && player.velocityY < 0 && (player.y + player.height <= obj.y + Math.abs(player.wallClimbAcceleration * (keys.w ? -1 : 1)))) {
                                    player.y = obj.y - player.height; onGround = true; player.isWallHolding = false;
                                } else if (player.velocityY >= 0 && player.y - player.velocityY + player.height <= obj.y + 1) {
                                    player.y = obj.y - player.height; player.velocityY = 0; onGround = true; 
                                    player.isWallHolding = false; player.jumpsMade = 0; player.coyoteTimeCounter = 0;
                                    if (jumpBufferCounter > 0) {
                                        player.velocityY = -player.jumpPower; player.jumpsMade = 1; jumpBufferCounter = 0;
                                    }
                                } else if (player.velocityY < 0 && player.y - player.velocityY >= obj.y + obj.height - 1) {
                                    player.y = obj.y + obj.height; player.velocityY = 0;
                                }
                            }
                        });

                        levelObjects.forEach(obj => {
                            if (obj.isSolid && obj.type === 'spike' && checkPlayerSpikeCollision(player, obj)) { resetPlayer(); } 
                            else if (checkRectCollision(player, obj)) {
                                if (obj.type === 'button' && !obj.activated) {
                                    obj.activated = true;
                                    if (obj.linkedTo) {
                                        obj.linkedTo.forEach(targetId => {
                                            const targetObj = levelObjects.find(t => t.id === targetId);
                                            if(targetObj) {
                                                if (targetObj.type === 'decay') {
                                                    targetObj.phased = true;
                                                    setTimeout(() => { targetObj.phased = false; obj.activated = false; }, 10000);
                                                }
                                                if (targetObj.type === 'end') {
                                                    gameWon = true;
                                                }
                                                if (targetObj.type === 'music' && activeAudio[targetObj.id]) {
                                                    Object.values(activeAudio).forEach(audio => audio.pause());
                                                    activeAudio[targetObj.id].currentTime = 0;
                                                    const playPromise = activeAudio[targetObj.id].play();
                                                    if (playPromise !== undefined) {
                                                        playPromise.catch(error => console.error("Audio play failed:", error));
                                                    }
                                                }
                                                if (targetObj.type === 'laser_source') {
                                                    levelObjects.forEach(l => { if(l.type === 'laser_source') { l.isActive = false; clearTimeout(l.activationTimeout); } });
                                                    if (obj.laserLinkDirection) {
                                                        targetObj.orientation = obj.laserLinkDirection;
                                                    }
                                                    let o = targetObj.orientation || 'left';
                                                    if (o === 'left' || o === 'right') targetObj.position = targetObj.x;
                                                    else targetObj.position = targetObj.y;
                                                    targetObj.activationTimeout = setTimeout(() => { targetObj.isActive = true; }, 500);
                                                }
                                            }
                                        });
                                    }
                                }
                            }
                        });
                        
                        if (!player.isWallHolding && !onGround && wallTouchDirection !== 0) {
                            player.isWallHolding = true;
                            player.wallDirection = wallTouchDirection;
                            player.jumpsMade = 0;
                            player.coyoteTimeCounter = 0;
                            player.velocityY = 0;
                        }
                    }
                     
                    if (player.x < 0) player.x = 0;
                    if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
                    
                    if (player.y > worldHeight) {
                        resetPlayer();
                    }
                }
            } else { // editorMode is true
                if (keys.d) camera.x += editorCameraSpeed; if (keys.a) camera.x -= editorCameraSpeed;
                if (keys.s) camera.y += editorCameraSpeed; if (keys.w) camera.y -= editorCameraSpeed;
            }

            // --- CAMERA AND DRAWING ---
            let targetCameraX = editorMode ? camera.x : player.x - canvas.width / 2 + player.width / 2;
            let targetCameraY = editorMode ? camera.y : player.y - canvas.height / 2 + player.height / 2;

            if (!editorMode) {
                camera.x += (targetCameraX - camera.x) * 0.1;
                camera.y += (targetCameraY - camera.y) * 0.1;
            } else {
                 camera.x = targetCameraX;
                 camera.y = targetCameraY;
            }
           
            if (camera.x < 0) camera.x = 0; if (camera.x + canvas.width > worldWidth) camera.x = worldWidth - canvas.width;
            if (camera.y < 0) camera.y = 0; if (camera.y + canvas.height > worldHeight) camera.y = worldHeight - canvas.height;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background video/image directly to canvas in SCREEN space
            // This makes the background fixed to the camera view and mimics object-fit: cover
            if (levelSettings.backgroundVideoSrc && !backgroundVideo.paused && backgroundVideo.readyState >= 3) {
                const ar = backgroundVideo.videoWidth / backgroundVideo.videoHeight;
                const cr = canvas.width / canvas.height;
                let dw = canvas.width, dh = canvas.height;
                let ox = 0, oy = 0;
                if (ar > cr) { dw = canvas.height * ar; ox = (canvas.width - dw) / 2; } 
                else { dh = canvas.width / ar; oy = (canvas.height - dh) / 2; }
                ctx.drawImage(backgroundVideo, ox, oy, dw, dh);
            } else if (levelBackgroundImage && levelBackgroundImage.complete) {
                const ar = levelBackgroundImage.width / levelBackgroundImage.height;
                const cr = canvas.width / canvas.height;
                let dw = canvas.width, dh = canvas.height;
                let ox = 0, oy = 0;
                if (ar > cr) { dw = canvas.height * ar; ox = (canvas.width - dw) / 2; } 
                else { dh = canvas.width / ar; oy = (canvas.height - dh) / 2; }
                ctx.drawImage(levelBackgroundImage, ox, oy, dw, dh);
            }
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // The background color is handled by the canvas style, so no need to fillRect here

            drawLevelObjects();
            
            if (editorMode) {
                drawEditorElements();
            } else {
                drawChasingLaser();
            }
            
            if (levelSettings.hookEnabled) {
                drawHook();
            }

            if(!gameWon) {
                drawPlayer();
            }
            
            ctx.restore();

            if (!editorMode) {
                drawActiveTextEvents();
            }

            if (gameWon) {
                drawWinMessage();
            }

            drawTimeline();
            requestAnimationFrame(update);
        }

        function startGame(playOnly = false) {
            isPlayOnlyMode = playOnly;
            editorMode = !playOnly;
            
            mainMenu.style.display = 'none';
            document.getElementById('editor-wrapper').style.display = 'flex';
            
            const controlsContainer = document.getElementById('controls-container');
            if (playOnly) {
                controlsContainer.style.display = 'none';
                resetPlayer();
                gameTimerDisplay.style.display = 'block';
                controlsDisplay.style.display = 'block';
            } else {
                controlsContainer.style.display = 'flex';
                controlsText.textContent = "EDITOR MODE [W,A,S,D to Pan | Q to Toggle]";
                gameTimerDisplay.style.display = 'none';
                controlsDisplay.style.display = 'none';
            }
        }
        
        const tutorialLevel = {
            settings: {
                laserSpeed: 1.5, playerMaxSpeed: 5, playerAcceleration: 0.4, playerJumpPower: 13,
                platformSpeed: 2,
                backgroundColor: '#1a2a3a',
                hookEnabled: true,
                timelineEvents: [
                    { id: 1, type: 'text', startTime: 1, duration: 5, text: "Use A/D to move, SPACE to jump.", fontSize: 24, color: '#FFFFFF' },
                    { id: 2, type: 'text', startTime: 7, duration: 5, text: "Aim with the mouse and press E to grapple.", fontSize: 24, color: '#FFFFFF' },
                    { id: 3, type: 'text', startTime: 13, duration: 5, text: "Use W/S while hooked to reel in or out.", fontSize: 24, color: '#FFFFFF' },
                    { id: 4, type: 'text', startTime: 19, duration: 5, text: "Swing fast and press E to fly!", fontSize: 24, color: '#FFFFFF' },
                ],
                backgroundImageSrc: null,
                backgroundVideoSrc: null,
            },
            objects: [
                { id: 10, type: 'platform', x: 0, y: worldHeight - 40, width: 400, height: 40, color: '#cccccc', isSolid: true },
                { id: 11, type: 'spawn', x: 40, y: worldHeight - 80, width: 20, height: 20, color: '#00e676', isSolid: true },
                { id: 12, type: 'platform', x: 550, y: worldHeight - 250, width: 250, height: 20, color: '#cccccc', isSolid: true },
                { id: 15, type: 'end', x: 750, y: worldHeight - 290, width: 20, height: 20, color: '#8e24aa', isSolid: true }
            ]
        };

        // --- Event Listeners Initialization ---
        
        startEditorBtn.addEventListener('click', () => {
            startGame(false);
        });
        
        playBtn.addEventListener('click', () => {
            mainMenuButtons.style.display = 'none';
            playSubMenu.style.display = 'flex';
        });

        backToMainBtn.addEventListener('click', () => {
            mainMenuButtons.style.display = 'flex';
            playSubMenu.style.display = 'none';
        });

        tutorialBtn.addEventListener('click', () => {
            loadLevelData(tutorialLevel, true);
        });
        
        fanLevelBtn.addEventListener('click', () => {
            isPlayOnlyMode = true;
            importFileInput.click();
        });

        controlsDisplay.innerHTML = `
            <ul>
                <li><b>Move:</b> A / D</li>
                <li><b>Jump:</b> Space</li>
                <li><b>Wall Climb:</b> W (on wall)</li>
                <li><b>Sprint:</b> Hold Shift + Move</li>
                <li><b>Dash/Slide:</b> Sprint + S</li>
                <li><b>Grapple:</b> E (Aim w/ mouse)</li>
            </ul>
        `;

        loadBackgroundMedia();
        addTextEventBtn.classList.add('active');

        saveState();
        resetPlayer();
        update();
    </script>
</body>
</html>




